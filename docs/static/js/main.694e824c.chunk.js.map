{"version":3,"sources":["Types.ts","untyped-lambda-integration/Types.ts","untyped-lambda-integration/TreeComparator.ts","misc/index.ts","untyped-lambda-integration/AppTypes.ts","AppTypes.ts","components/TopBar.tsx","components/MenuBar.tsx","markdown-integration/AppTypes.ts","components/PickBoxTypeModal.tsx","components/CreateBox.tsx","untyped-lambda-integration/ReactPrinter.tsx","untyped-lambda-integration/ReductionMessage.tsx","untyped-lambda-integration/Step.tsx","untyped-lambda-integration/InactiveExpression.tsx","components/Editor.tsx","components/DebugControls.tsx","untyped-lambda-integration/Expression.tsx","untyped-lambda-integration/ExpressionBox.tsx","untyped-lambda-integration/MacroList.tsx","untyped-lambda-integration/ExerciseBox.tsx","untyped-lambda-integration/Settings.tsx","untyped-lambda-integration/EmptyExpression.tsx","untyped-lambda-integration/UntypedLambdaBox.tsx","markdown-integration/Note.tsx","empty-integration/index.tsx","components/Box.tsx","untyped-lambda-integration/BoxTopBar.tsx","markdown-integration/BoxTopBar.tsx","empty-integration/BoxTopBar.tsx","components/BoxTitleBar.tsx","components/BoxContainer.tsx","screens/Notebook.tsx","screens/Help.tsx","misc/UserGuide.ts","screens/Settings.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["BoxType","Screen","PromptPlaceholder","UntypedLambdaType","EvaluationStrategy","TreeComparator","roots","translator","Map","equals","context","this","compare","left","right","Lambda","backup","entries","set","argument","name","Application","Macro","ChurchNumeral","Variable","has","get","reportEvent","category","action","label","window","ga","getAll","send","exception","UNTYPED_LAMBDA_INTEGRATION_STATE","macrotable","CODE_NAME","defaultSettings","type","UNTYPED_LAMBDA","SLI","expandStandalones","strategy","NORMAL","SDE","createNewUntypedLambdaExpression","__key","Date","now","toString","subtype","EMPTY","title","minimized","menuOpen","settingsOpen","expression","ast","history","isRunning","breakpoints","timeoutID","undefined","timeout","macrolistOpen","editor","placeholder","content","caretPosition","syntaxError","toMacroMap","definitions","reduce","acc","def","split","body","trim","createNewUntypedLambdaBoxFromSource","source","pop","macromap","tokens","tokenize","lambdaLetters","singleLetterVars","parse","message","isNormal","astCopy","clone","findSimplifiedReduction","strategyToEvaluator","nextReduction","None","lastReduction","step","isNormalForm","EVAL_MODE","createNewUntypedLambdaBoxFromSource2","GLOBAL_SETTINGS_ENABLER","evaluator","Expansion","target","newAst","perform","newreduction","parent","treeSide","M","expanded","newperformevaluation","findRedexIn","tree","reduction","ASTReductionType","ALPHA","alpha","Array","from","conversions","some","lambda","identifier","BETA","beta","ETA","eta","EXPANSION","expansion","GAMA","macrobeta","applications","length","_","redex","arity","getFnArgNames","arit","macroname","includes","getArityOfKnownMacro","macroAppRedex","basepoint","extender","NormalMacroRedexExtender","MacroBeta","parents","extendMacroAppRedex","APPLICATIVE","app","argreduction","argperformevaluation","lastapp","lastparent","appParent","shift","Child","Left","Right","reducer","reduced","macro","macroIsSingleStep","evaluateReduction","tryMacroContraction","resAST","isPeanoNumber","s","z","isChurchNumeral","n","matches","match","RegExp","churchNumeralToNumber","churchArgNames","Object","builtinMacros","definition","macroast","found","visit","application","push","variable","ASTVisitor","NormalEvaluator","ApplicativeEvaluator","OPTIMISATION","OptimizeEvaluator","ABSTRACTION","NormalAbstractionEvaluator","ALL_BOX_TYPES","LISP","MARKDOWN","DEFAULT_WHITELIST","InitNotebookState","boxList","activeBoxIndex","NaN","focusedBoxIndex","allowedBoxes","settings","getDefaultSettings","integrationStates","locked","editingName","persistent","HoloNotebookState","UntypedLambdaDefaultSettings","HoloAppState","MAIN","notebookList","currentNotebook","currentScreen","whitelist","UNTYPED_CODE_NAME","loadSettingsFromStorage","serialized","localStorage","getItem","deserialized","JSON","key","value","console","error","TopBar","props","state","onClearWorkspace","onImport","onScreenChange","ntbk","data","Blob","URL","createObjectURL","createURL","stringify","className","onClick","MenuBar","id","href","HELP","onMarkDownBlur","isEditing","isAllowed","anyBoxAllowed","PickBoxTypeModal","addNew","whiteList","untLSettings","e","stopPropagation","allowed","addLispBoxIfAllowed","note","addMDBoxIfAllowed","CreateBox","modalOpen","box","setState","Component","ReactPrinter","rendered","redexesFound","accumulator","isBreakpoint","Alpha","conversion","args","Symbol","broken","Set","printMultiLambda","node","leftClassName","rightClassName","Beta","Gama","churchNumber","redexes","redexClass","ReductionMessage","StepMemo","memo","stepRecord","addBreakpoint","children","newast","printer","incorrectStep","indexOf","correctStep","exerciseStep","print","substr","lastStep","StepWrapper","InactiveExpression","ActionType","Editor","submitOnEnter","shouldReplaceLambda","onContent","onEnter","onShiftEnter","onCtrlEnter","onChange","replace","InputField","onKeyDown","event","shiftKey","ctrlKey","preventDefault","lines","onKeyDownCapture","height","Math","max","min","language","theme","options","formatOnPaste","minimap","enabled","renderLineHighlight","scrollBeyondLastLine","overviewRulerBorder","scrollbar","editorDidMount","monaco","focus","DebugControls","document","onkeydown","log","altKey","metaKey","onStep","onRun","runMessage","disabled","PureComponent","Expression","bind","shouldShowDebugControls","isExercise","setBoxState","uniq","to","sequence","fn","result","i","mapLeftFromTo","onExecute","checked","htmlFor","style","breakpoint","brkpts","filter","brk","ExpressionBox","onSimplifiedStep","onStop","shouldBreak","createBoxFrom","onSimplifiedRun","isActive","addBox","map","join","isNowNormalForm","setTimeout","arityBreakpoint","find","clearTimeout","add","normal","MacroList","macroTable","macroName","macroExpression","ExerciseBox","onSubmitExpression","parseExpression","onExerciseStep","userAst","VALIDATE_MODE","macroContext","Settings","change","settingsEnabled","SLI_E","strat_E","EmptyExpression","isMinimized","onDebug","onExercise","UntypedLambdaBox","isFocused","ref","elem","boundingRect","getBoundingClientRect","viewportHeight","innerHeight","bottom","scrollIntoView","ORDINARY","EXERCISE","renderBoxContent","ReactMarkdown","require","Note","Empty","Box","updateBoxState","addBoxAfter","BoxTopBar","removeBox","Switch","EmptyTopBar","BoxTitleBar","where","shareLinkOpen","selectBoxType","addBoxBefore","searchParams","location","encodeURI","url","host","navigator","clipboard","writeText","resetUntypedLambdaBox","resetMarkdownBox","place","BoxContainer","isActiveBox","isFocusedBox","makeActive","onBlur","boxTypeClassName","mapBoxTypeToStr","Notebook","insertBefore","insertAfter","createBoxFromURL","updateURL","index","boxState","boxListCopy","splice","updateNotebook","newIndex","patch","Help","SettingsScreen","updateSettings","untypedSettings","UNTYPED_GLOBAL_SETTINGS_ENABLER","unTypLSet","App","setScreen","changeNotebook","clearWorkspace","selectNotebook","updateNthNotebook","createNotebookFromURL","urlSearchParams","strat","sli","sub","notebook","createNewNotebookWithBox","decodeURI","pushState","ex","replaceState","reload","SETTINGS","screen","newSettings","confirm","Boolean","hostname","ReactDOM","render","getElementById","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.694e824c.chunk.js","sourcesContent":["import { UntypedLambdaState, UntypedLambdaSettings, UntypedLambdaIntegrationState } from \"./untyped-lambda-integration/Types\"\nimport { NoteState } from \"./markdown-integration/AppTypes\"\n\nexport enum BoxType {\n  UNTYPED_LAMBDA = 'UNTYPED_LAMBDA',\n  LISP = 'LISP',\n  MARKDOWN = 'MARKDOWN',\n}\n\nexport enum Screen {\n  MAIN,\n  HELP,\n  // MACROLIST,\n  SETTINGS,\n  NOTEBOOKS, // TODO: this will be the final solution to the `Multiple Notebooks` problem\n}\n\nexport type AnyBox = -1\n\nexport type NoBox = -2\n\n// TODO: when building `Exam Mode`  allow only Array<BoxType> or NoBox\nexport type BoxesWhitelist = Array<BoxType> | AnyBox | NoBox\n\nexport interface AbstractIntegrationState {}\n\nexport interface AbstractBoxState {\n  type : BoxType,\n  __key : string, \n  title : String,\n  minimized : boolean,\n  menuOpen : boolean,\n  settingsOpen : boolean,\n}\n\nexport interface AbstractSettings {\n  type : BoxType,\n}\n\nexport interface LispBox extends AbstractBoxState {\n  // TODO: delete this placeholder and implement it\n}\n\nexport interface LispSettings extends AbstractSettings {\n  // TODO: delete this placeholder and implement it\n}\n\nexport type BoxState = UntypedLambdaState | LispBox | NoteState // or other things in the future\n\nexport type Settings = UntypedLambdaSettings | LispSettings // or other things in the future\n\nexport type IntegrationState = UntypedLambdaIntegrationState // | Others\n\nexport interface IntegrationStates {\n  [key : string] : IntegrationState  // TODO: FIX THIS!!!\n}\n\n// TODO: this needs to be reconsidered\nexport interface GlobalSettings {\n  // [UNTYPED_CODE_NAME] : UntypedLambdaSettings\n  [key : string] : Settings\n}\n\nexport interface NotebookState {\n  boxList : Array<BoxState>\n  activeBoxIndex : number\n  focusedBoxIndex : number | undefined\n  allowedBoxes : BoxesWhitelist\n\n  locked : boolean\n  menuOpen : boolean\n\n  settings : GlobalSettings // TODO: refactor to use the Dictionary\n  integrationStates : IntegrationStates\n\n  __key : string\n  name : string\n  editingName : boolean\n  persistent : boolean\n}\n\nexport interface AppState {\n  notebookList : Array<NotebookState>,\n  currentNotebook : number,\n  currentScreen : Screen,\n}\n\n\n// // TODO: move to specific integration\n// export interface MacroDefinitionState {\n//   __key : string\n//   type : BoxType\n//   macroName : string\n//   macroExpression : string\n//   singleLetterNames : boolean\n//   editor : {\n//     placeholder : string\n//     content : string\n//     caretPosition : number\n//     syntaxError : Error | null\n//   }\n// }\n\n\n\n","import { AbstractSettings, BoxType, AbstractBoxState, AbstractIntegrationState } from \"../Types\"\nimport { AST, ASTReduction, ASTReductionType, NormalEvaluator, ApplicativeEvaluator, OptimizeEvaluator, MacroMap } from \"@lambdulus/core\"\n\n\nexport interface UntypedLambdaIntegrationState extends AbstractIntegrationState {\n  macrotable : MacroMap\n}\n\nexport enum PromptPlaceholder {\n  INIT = 'Type λ (as \\\\) expression and hit enter',\n  EVAL_MODE = 'Hit enter for next step',\n  VALIDATE_MODE = 'Write next step and hit enter for validation',\n  MACRO = 'Define Macro like: `NAME := [λ expression]` and hit enter',\n  NOTE = 'Type note and hit shift enter'\n}\n\nexport enum UntypedLambdaType {\n  EMPTY = 'EMPTY',\n  ORDINARY = 'ORDINARY',\n  EXERCISE = 'EXERCISE',\n  // MACRO,\n}\n\nexport type Breakpoint = {\n  type : ASTReductionType,\n  context : AST,\n  broken : Set<AST>,\n}\n\nexport interface StepRecord {\n  ast : AST\n  lastReduction : ASTReduction | null\n  step : number\n  message : string\n  isNormalForm : boolean\n}\n\nexport enum EvaluationStrategy {\n  NORMAL = 'Normal Evaluation',\n  APPLICATIVE = 'Applicative Evaluation',\n  OPTIMISATION = 'Optimisation - η Conversion',\n  ABSTRACTION = 'Abstraction / Simplified Evaluation'\n}\n\nexport type UntypedLambdaState = UntypedLambdaExpressionState // | UntypedLambdaMacroState\n\n// TODO: consider abstract Untype Lambda State which will hold all common members\n\nexport interface UntypedLambdaExpressionState extends AbstractBoxState {\n  __key : string\n  type : BoxType\n\n  subtype : UntypedLambdaType\n  expression : string\n  ast : AST | null\n  history : Array<StepRecord>\n  isRunning : boolean\n  breakpoints : Array<Breakpoint>\n  timeoutID : number | undefined\n  timeout : number\n  // isExercise : boolean\n  \n  strategy : EvaluationStrategy\n  SDE : boolean // Semantics Drive Evaluation (Strategy) -- formerly called Simplified Strategy\n  SLI : boolean\n  expandStandalones : boolean\n\n  macrolistOpen : boolean // this is gonna go out\n  macrotable : MacroMap // this is gonna go out - WHY? I don't think so - it's gonna stay\n  \n  editor : {\n    placeholder : string\n    content : string\n    caretPosition : number\n    syntaxError : Error | null\n  }\n}\n\n// export interface UntypedLambdaMacroState extends AbstractBoxState {\n//   __key : string\n//   type : BoxType\n\n//   subtype : UntypedLambdaType\n//   expression : string\n//   ast : AST | null\n//   macroName : string\n//   macroExpression : string\n  \n//   SLI : boolean\n//   expandStandalones : boolean\n//   strategy : EvaluationStrategy\n\n//   macrolistOpen : boolean\n//   macrotable : MacroMap\n\n//   editor : {\n//     placeholder : string\n//     content : string\n//     caretPosition : number\n//     syntaxError : Error | null\n//   }\n// }\n\nexport interface UntypedLambdaSettings extends AbstractSettings {\n  SLI : boolean\n  expandStandalones : boolean\n  strategy : EvaluationStrategy\n  SDE : boolean\n}\n\nexport type SettingsEnabled = {\n  SLI : boolean\n  expandStandalones : boolean\n  strategy : boolean\n}\n\nexport type Evaluator = NormalEvaluator | ApplicativeEvaluator | OptimizeEvaluator\n","import { AST, Lambda, Application, Macro, ChurchNumeral, Variable } from \"@lambdulus/core\"\n\n///////////////////////////////////////////////////////////////////////////////////////\n\ntype Pair<T> = [T, T]\ntype Triple<T> = [T, T, T]\n\n\n// TODO: fix the public equals interface, maybe public get and private set?\n// maybe implement public get method and bool itself leave private?\n//\n// first I need more trees, I need the previous AST\nexport class TreeComparator {\n  private translator : Map<string, string> = new Map\n  public equals : boolean = true\n  private context : Pair<AST>\n\n  constructor (readonly roots : Pair<AST> ) {\n    [ ...this.context ] = roots\n    // TODO: I need to compare roots first\n    this.compare()\n  }\n\n  compare () : void {\n    /**\n    TODO: compare need to compare both children if got\n    if one of them is incorrect\n    then solve that problem\n    if both of them is incorrect\n    then solve both problems and then decide how both come together\n\n    then I have an instance of knowledge system\n    I can fire up that system in this context (this node with invalid children)\n    system will need to get instance of something to call methods on\n    because system needs to ask questions - like, is this possible,\n    is this error applicable?\n    so instead of human, code will look up the AST and answer the questions\n    so it will be some kind of class which is able to observe all 3 ASTs at the same time\n    it will also have implemented query methods,\n    probably wont be many of them, just few\n    **/\n    \n    const [ left, right ] : Pair<AST> = this.context\n\n    if (left instanceof Lambda && right instanceof Lambda) {\n      const backup : Map<string, string> = new Map(this.translator.entries())\n\n      this.translator.set(left.argument.name(), right.argument.name())\n      this.context = [ left.right, right.right ]\n      this.compare()\n\n      this.translator = backup\n    }\n    else if (left instanceof Application && right instanceof Application) {\n      this.context = [ left.left, right.left ]\n      this.compare()\n\n      if ( ! this.equals) {\n        return\n      }\n\n      this.context = [ left.right, right.right ]\n      this.compare()\n    }\n    else if (left instanceof Macro && right instanceof Macro) {\n      this.equals = left.name() === right.name()\n    }\n    else if (left instanceof ChurchNumeral && right instanceof ChurchNumeral) {\n      this.equals = left.name() === right.name()\n    }\n    else if (left instanceof Variable && right instanceof Variable) {\n      if (this.translator.has(left.name())) {\n        this.equals = this.translator.get(left.name()) === right.name()\n      }\n      else {\n        this.equals = left.name() === right.name()\n      }\n    }\n    else {\n      this.equals = false\n    }\n  }\n}","import { MacroMap } from \"@lambdulus/core\"\n\n\nexport function debounce (fn : Function, treshold : number)\n : [ (...args : Array<any>) => void, () => void ] {\n  let timer : number\n  \n  return [\n    function debounced (...args : Array<any>) : void {\n      window.clearTimeout(timer)\n\n      timer = window.setTimeout(() => {\n        fn(...args)\n      }, treshold)\n    },\n    function cancel () : void {\n      window.clearTimeout(timer)\n    }\n  ]\n}\n\n// export function getSavedMacros () : MacroMap {\n//   return JSON.parse(window.localStorage.getItem('macrotable') || '{}')\n// }\n\nexport function trimStr (str : string) : string {\n  return str.trim()\n}\n\nexport function mapLeftFromTo(\n  from : number,\n  to : number,\n  sequence : Array<any>,\n  fn : (...args : Array<any>) => any) {\n    const result : Array<any> = new Array(to - from + 1)\n\n    for (let e = 0, i = from; i <= to; ++i) {\n      result[e++] = fn(sequence[i], i)\n    }\n\n    return result\n  }\n\n// export const HANDY_MACROS : MacroMap = {\n//   // 'Y' : '(λ f . (λ x . f (x x)) (λ x . f (x x)))',\n//   // 'Z' : '(λ f . (λ y . f (λ z . y y z)) (λ y . f (λ z . y y z)))',\n//   // FACT : '(Y (λ f n . (<= n 1) 1 (* n (f (- n 1)))))',\n//   // FACCT : '(λ n . (Y (λ f n a . IF (= n 1) a (f (- n 1) (* n a)))) (- n 1) (n))',\n//   // FIB : '(Y (λ f n . (= n 0) 0 ((= n 1) 1 ( + (f (- n 1)) (f (- n 2))))))',\n//   // // SHORTLIST : 'CON 3 (CONS 5 (CONS 1 NIL))',\n//   // // LONGLIST :  '(CONS 3 (CONS 5 (CONS 1 (CONS 10 (CONS 7 (CONS 2 (CONS 4 (CONS 9 (CONS 4 (CONS 6 (CONS 8 NIL)))))))))))',\n//   // APPEND : 'Y (λ fn listA listB . IF (NULL listA) (listB) (CONS (FIRST listA) (fn (SECOND listA) listB)))',\n//   // LISTGREQ : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (>= (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // LISTLESS : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (< (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // LISTGR : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (> (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // LISTEQ : 'Y (λ fn piv list . IF (NULL list) (NIL) ( IF (= (FIRST list) piv) (CONS (FIRST list) (fn piv (SECOND list))) (fn piv (SECOND list)) ) )',\n//   // QUICKSORT : 'Y (λ fn list . IF (NULL list) (NIL) ( IF (NULL (SECOND list)) (list) ( APPEND (fn (LISTLESS (FIRST list) list)) ( APPEND (LISTEQ (FIRST list) list) (fn (LISTGR (FIRST list) list)) ) ) ) )',\n//   // INFLIST : '(λ n . (Y (λ x . (λ f s g . g f s) n x)))',\n//   // REMOVENTH : 'Y (λ fn list n . IF (= n 0) (SECOND list) (IF (NULL list) NIL (CONS (FIRST list) (fn (SECOND list) (- n 1) ) ) ) )',\n//   // NTH : 'Y (λ fn list n . IF (= n 0) (FIRST list) (IF (NULL (list)) NIL (fn (SECOND list) (- n 1)) ) )',\n//   // LEN : 'Y (λ fn list . IF (NULL list) (0) (+ 1 (fn (SECOND list) )) )',\n//   // GETNTH : '(λ end . (Y (λ f n i . (end i) (i) ( (= n 0) (Y (λ f a . (end a) (i) (f) ) ) (f (- n 1)) ) )) )',\n//   // MAP : '(λ fn l . (Y (λ f it . IF (NULL it) (NIL) (CONS (fn (FIRST it)) (f (SECOND it))) )) l )',\n//   // REDUCE : '(λ fn l init . Y (λ f it acc . IF (NULL it) (acc) (f (SECOND it) (fn (FIRST it) acc)) ) l init )',\n//   // APPLY : '(λ f args . Y (λ ff f l . (NULL l) (f) (ff (f (FIRST l)) (SECOND l)) ) f args )',\n//   // RANGE : '(λ m n . Y (λ f e . (= e n) (CONS e NIL) (CONS e (f (+ e 1))) ) m )',\n//   // LISTCOMPR : '(λ args . APPLY (λ op in rng cond . Y (λ f l . (NULL l) (NIL) ( (cond (FIRST l)) (CONS (op (FIRST l)) (f (SECOND l))) (CONS (FIRST l) (f (SECOND l))) ) ) rng ) args )',\n//   // MOD : '(λ n m . (n (λ n . (= n (- m 1)) (0) (+ n 1)) (0)) )',\n//   // INFIX : 'APPLY (λ l op r . op l r)',\n// }\n\n// export function updateMacros (macroTable : MacroMap) : void {\n//   window.localStorage.setItem('macrotable', JSON.stringify(macroTable))\n// }\n\nexport function reportEvent (category : string, action : string, label : string) : void {\n  try {\n    const tracker = (window as any).ga.getAll()[0]\n    \n    tracker.send('event', category, action, label )\n  }\n  catch (exception) {\n    // instead of printing to the console - show notification on the web\n    // console.log(\"\")\n    // console.log('PLEASE DISABLE YOUR ADBLOCKER OR ALLOW GOOGLE ANALYTICS FOR THIS SITE')\n    // console.log(\"\")\n    // console.error(exception)\n  }\n}","import { BoxType } from '../Types'\nimport { EvaluationStrategy, UntypedLambdaState, UntypedLambdaSettings, UntypedLambdaType, StepRecord, UntypedLambdaExpressionState, UntypedLambdaIntegrationState, SettingsEnabled, PromptPlaceholder } from \"./Types\"\nimport { ASTReduction, AST, decodeFast as decodeUntypedLambdaFast, Evaluator, NormalEvaluator, None, Expansion, Macro, ASTReductionType, Alpha, Lambda, Beta, Eta, Application, ASTVisitor, Variable, ChurchNumeral, BetaReducer, builtinMacros, MacroTable, Token, tokenize, parse, TokenType, ApplicativeEvaluator, OptimizeEvaluator, NormalAbstractionEvaluator, MacroMap } from '@lambdulus/core'\nimport { Child, Binary } from '@lambdulus/core/dist/ast'\nimport { TreeComparator } from './TreeComparator'\nimport { PositionRecord, BLANK_POSITION } from '@lambdulus/core/dist/lexer/position'\nimport { reportEvent } from '../misc'\n\n// import macroctx from './MacroContext'\n\n// NOTE: let instead of const just for now\nexport let UNTYPED_LAMBDA_INTEGRATION_STATE : UntypedLambdaIntegrationState = {\n  macrotable : {}\n}\n\nexport const ADD_BOX_LABEL = '+ Untyped λ Expression'\n\nexport const CODE_NAME = 'UNTYPED_LAMBDA_CALCULUS'\n\nexport const defaultSettings : UntypedLambdaSettings = {\n  type : BoxType.UNTYPED_LAMBDA,\n  SLI : true,\n  expandStandalones : false,\n  strategy : EvaluationStrategy.NORMAL,\n  SDE : true,\n}\n\nexport function createNewUntypedLambdaExpression (defaultSettings : UntypedLambdaSettings) : UntypedLambdaExpressionState {\n  return {\n    ...defaultSettings,\n    __key : Date.now().toString(),\n    type : BoxType.UNTYPED_LAMBDA,\n    subtype : UntypedLambdaType.EMPTY,\n    title : \"Untyped λ Expression\",\n    minimized : false,\n    menuOpen : false,\n    settingsOpen : false,\n    expression : \"\",\n    ast : null,\n    history : [],\n    isRunning : false,\n    breakpoints : [],\n    timeoutID : undefined,\n    timeout : 5,\n    \n    // strategy : EvaluationStrategy.NORMAL,\n    // singleLetterNames : false,\n    // standalones : false,\n\n    macrolistOpen : false,\n    macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n    \n    editor : {\n      placeholder : \"placeholder\",\n      content : \"\",\n      caretPosition : 0,\n      syntaxError : null,\n    }\n  }\n}\n\nexport function toMacroMap (definitions : Array<string>) : MacroMap {\n  return definitions.reduce((acc : MacroMap, def) => {\n    const [name, body] = def.split(':=')\n    return { ...acc, [name.trim()] : body.trim() }\n  }, {})\n}\n\nexport function createNewUntypedLambdaBoxFromSource (source : string, defaultSettings : UntypedLambdaSettings, subtype : UntypedLambdaType) : UntypedLambdaExpressionState {\n  if (subtype === UntypedLambdaType.EMPTY) {\n    return {\n      ...defaultSettings,\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype,\n      title : \"Untyped λ Expression\",\n      minimized : false,\n      menuOpen : false,\n      settingsOpen : false,\n      expression : \"\",\n      ast : null,\n      history : [],\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 5,\n      \n      // strategy : EvaluationStrategy.NORMAL,\n      // singleLetterNames : false,\n      // standalones : false,\n  \n      macrolistOpen : false,\n      macrotable : {  }, // ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable\n  \n      \n      editor : {\n        placeholder : \"placeholder\",\n        content : source,\n        caretPosition : 0,\n        syntaxError : null,\n      }\n    }\n  }\n  else {\n    return createNewUntypedLambdaBoxFromSource2(source, defaultSettings, subtype)\n  }\n}\n\nfunction createNewUntypedLambdaBoxFromSource2 (source : string, defaultSettings : UntypedLambdaSettings, subtype : UntypedLambdaType) : UntypedLambdaExpressionState {\n  const { SDE, SLI, strategy } = defaultSettings\n\n  const definitions : Array<string> = source.split(';')\n  const expression : string = definitions.pop() || \"\"\n  const macromap : MacroMap = toMacroMap(definitions)\n  \n  try {\n    const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars : SLI })\n    const ast : AST = parse(tokens, macromap) // macroTable\n    \n    \n    let message = ''\n    let isNormal = false\n\n    const astCopy : AST = ast.clone()\n\n    const nextReduction = (() => {\n      if (SDE) {\n        return findSimplifiedReduction(astCopy, strategy, macromap)[0]\n      }\n      else {\n        const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n        return evaluator.nextReduction\n      }\n    })()\n\n    \n    if (nextReduction instanceof None) {\n      isNormal = true\n      message = 'Expression is in normal form.'\n      \n      // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n    }\n\n    reportEvent('Submit Expression from Link', 'submit valid', source)\n\n    return {\n      ...defaultSettings,\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype,\n      title : \"Untyped λ Expression\",\n      minimized : false,\n      menuOpen : false,\n      settingsOpen : false,\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 5,\n      ast,\n      expression : source,\n      history : [ {\n        ast : ast.clone(),\n        lastReduction : new None,\n        step : 0,\n        message,\n        isNormalForm : isNormal\n      } ],\n\n      macrolistOpen : false,\n      macrotable : macromap,\n      // macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n      editor : {\n        content : source,\n        caretPosition : 0,\n        placeholder : PromptPlaceholder.EVAL_MODE,\n        syntaxError : null,\n      }\n    }\n\n  } catch (exception) {\n    reportEvent('Submit Expression from Link', 'submit invalid', source)\n    throw exception\n  }\n}\n\nexport function resetUntypedLambdaBox (state : UntypedLambdaState) : UntypedLambdaState {\n  return {\n    ...state,\n    subtype : UntypedLambdaType.EMPTY,\n    title : \"Untyped λ Expression\",\n    minimized : false,\n    expression : \"\",\n    ast : null,\n    history : [],\n    isRunning : false,\n    breakpoints : [],\n    timeoutID : undefined,\n    timeout : 5,\n    \n    macrolistOpen : false,\n    macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n    \n    editor : {\n      placeholder : \"placeholder\",\n      content : \"\",\n      caretPosition : 0,\n      syntaxError : null,\n    }\n  }\n}\n\n// export function createNewUntypedLambdaExercise (defaultSettings : UntypedLambdaSettings) : UntypedLambdaState {\n//   return {\n//     ...defaultSettings,\n//     __key : Date.now().toString(),\n//     type : BoxType.UNTYPED_LAMBDA,\n//     subtype : UntypedLambdaType.EXERCISE,\n//     title : \"Untyped λ Exercise\",\n//     minimized : false,\n//     menuOpen : false,\n//     settingsOpen : false,\n//     expression : \"\",\n//     ast : null,\n//     history : [],\n//     isRunning : false,\n//     breakpoints : [],\n//     timeoutID : undefined,\n//     timeout : 5,\n    \n//     // strategy : EvaluationStrategy.NORMAL,\n//     // singleLetterNames : false,\n//     // standalones : false,\n\n//     macrolistOpen : false,\n//     macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n    \n//     editor : {\n//       placeholder : \"placeholder\",\n//       content : \"\",\n//       caretPosition : 0,\n//       syntaxError : null,\n//     }\n//   }\n// }\n\n// export function createNewUntypedLambdaMacro (defaultSettings : UntypedLambdaSettings) : UntypedLambdaMacroState {\n//   return (\n//     {\n//       ...defaultSettings,\n//       __key : Date.now().toString(),\n//       type : BoxType.UNTYPED_LAMBDA,\n//       title : \"Untyped λ Macro Expression\",\n//       minimized : false,\n//       menuOpen : false,\n//       settingsOpen : false,\n    \n//       subtype : UntypedLambdaType.MACRO,\n//       expression : '',\n//       ast : null,\n//       macroName : '',\n//       macroExpression : '',\n\n//       macrolistOpen : false,\n//       macrotable : { ...UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable },\n\n      \n//       editor : {\n//         placeholder : PromptPlaceholder.MACRO,\n//         content : '',\n//         caretPosition : 0,\n//         syntaxError : null\n//       }\n//     }\n//   )\n// }\n\n\nexport function decodeUntypedLambdaState (box : UntypedLambdaState) : UntypedLambdaState {\n  return decodeUntypedLambdaExpression(box as UntypedLambdaExpressionState)\n\n  // switch (box.subtype) {\n  //   case UntypedLambdaType.ORDINARY:\n  //     return decodeUntypedLambdaExpression(box as UntypedLambdaExpressionState)\n      \n    // case UntypedLambdaType.MACRO:\n    //   return box //TODO: implement -- it's not really needed\n\n    // case UntypedLambdaType.EXERCISE:\n    //   return decodeUntypedLambdaExpression(box as UntypedLambdaExpressionState)\n  // }\n}\n\nfunction decodeUntypedLambdaExpression (box : UntypedLambdaExpressionState) : UntypedLambdaExpressionState {\n  const untypedLambdaBox : UntypedLambdaExpressionState = box as UntypedLambdaExpressionState\n\n  if (untypedLambdaBox.expression === '') {\n    return untypedLambdaBox\n  }\n  \n  const decodedFirst : AST | null = decodeUntypedLambdaFast(untypedLambdaBox.ast)\n\n  if (decodedFirst === null) {\n    // TODO: repair:\n    // parse expression\n    // replace untypedLambdaBox.ast with parsed AST\n    // for now - throw error\n    throw \"ROOT AST IS NOT DECODABLE\"\n  }\n\n  untypedLambdaBox.ast = decodedFirst\n  untypedLambdaBox.history = untypedLambdaBox.history.map((step : StepRecord, index : number) => {\n    let decodedNth : AST | null = decodeUntypedLambdaFast(step.ast) as AST\n\n    if (decodedNth === null) {\n      // TODO: repair:\n      // try to take previous Step.ast and do the evaluation\n      // though - remember this Step.step (number) may not be + 1 of the previous one\n      // you will need to do the steps as long as need to be\n      // replace decodedNth with parsed AST\n      // for throw\n      throw \"CURRENT STEP IS NOT DECODABLE \" + index\n    }\n\n    // TODO: maybe instead of this theatre just use the Core . Evalautor\n    // and get real instance of ASTReduction\n    let reduction : ASTReduction | undefined | null = step.lastReduction\n\n    if (step.lastReduction === undefined) {\n      reduction = null\n    }\n\n    return {\n      ...step,\n      lastReduction : reduction,\n      ast : decodedNth, // TODO: as AST this is unsafe\n    }\n  })\n\n  return untypedLambdaBox\n}\n\nexport const GLOBAL_SETTINGS_ENABLER : SettingsEnabled = {\n  SLI : true,\n  expandStandalones : true,\n  strategy : true,\n}\n\n// export const MACRO_SETTINGS_ENABLER : SettingsEnabled = {\n//   SLI : true,\n//   expandStandalones : false,\n//   strategy : false,\n// }\n\ntype PerformEvaluation = (ast : AST) => AST\n\n\nexport function findSimplifiedReduction (ast : AST, strategy : EvaluationStrategy, macrotable : MacroTable) : [ASTReduction, PerformEvaluation] {\n  const evaluator : Evaluator =  new (strategyToEvaluator(strategy) as any)(ast) // new NormalEvaluator(ast) // TODO: get evaluator dipending on the strategy in the future\n  const nextReduction = evaluator.nextReduction\n\n  // nothing to do\n  // TODO: try to contract this whole expression if it's actually known Macro\n  if (evaluator.nextReduction instanceof None) {\n    return [nextReduction, (ast) => ast]\n  }\n\n  if (nextReduction instanceof Expansion && nextReduction.target instanceof ChurchNumeral) {\n    // console.log(\"_________________________________ CHURCH NUMERAL EXPANSION\")\n\n    const newAst = evaluator.perform() // expand Number\n\n    //\n    // ast je cely vyraz - po performu uz modifikovany\n    // newAst je ted to same jako ast\n    // uvnitr celeho stromu hledam dalsi REDEX\n    //\n    const [newreduction, newperformevaluation] = findSimplifiedReduction(newAst, strategy, macrotable)\n\n    // return [nextReduction, (ast) => newAst]\n\n    if (newreduction instanceof None) {\n      //\n      // newAst nema zadny REDEX\n      // reknu ze se ma provest expanze Churche + vratim funkci, ktera jenom vrati AST ktery je ji poslany\n      // takhle to funguje proto - ze nemuzu naklonovat ast kdyz se findSimplifiedReduction zavola\n      // protoze by pak nesouhlasili identifikatory a podobne --> to vede na to, ze to co mi do findSimplifiedReduction\n      // je poslano - to zmodifikuju a pak proste jenom predpokladam, ze to nikomu nevadi\n      // ukazka naprosto spatnyho designu provadeni redukci a faktu ze AST melo byt immutable\n      //\n\n      // console.log(\"_________________________________ rule I. INSIDE EXPANSION\")\n      return [newreduction, (ast) => ast]\n      // NO REDEX FOUND --> normal form, not expanding Church Numeral\n      // means - I should signal normal form -- perhaps there is a problem\n      // --> previous step should already be normal form\n      // but this way user finds out this is terminal state only after hitting - next step manually -- possible fix?\n    }\n    else {\n      // there's REDEX --> I know for a fact that it's not rule III. (inside the expanded expression)\n      // now - because Church Numerals DON'T have arity - they are supposed to be numbers and not Macros\n      // I can just forgot all the complex ruling and do the sensible thing --> perform \n\n      // console.log(\"_________________________________ CHURCH EXPAND -- INSIDE EXPANSION\")\n      return [nextReduction, (ast) => newAst]\n    }\n  }\n\n  if (nextReduction instanceof Expansion && nextReduction.target instanceof Macro) {\n    // console.log(\"_________________________________ MACRO EXPANSION\")\n    // debugger\n    \n    const { parent, treeSide, target, type } : Expansion = nextReduction\n    \n    const M : Macro = target.clone()\n\n    const newAst = evaluator.perform()\n    const expanded = parent !== null && treeSide !== null ? parent[treeSide].clone() : newAst.clone()\n    // const expanded = parent !== null && treeSide !== null ? parent[treeSide] : newAst\n\n    //\n    // newAst je cely vyraz po expanzi soucasneho makra\n    // v nem vyhledam dalsi REDEX\n    //\n    const [newreduction, newperformevaluation] = findSimplifiedReduction(newAst, strategy, macrotable)\n    // const newevaluator = new NormalEvaluator(newAst)\n    // const newreduction = newevaluator.nextReduction\n\n    if (newreduction instanceof None) {\n      // console.log(\"_________________________________ rule I. INSIDE EXPANSION\")\n      return [newreduction, (ast) => ast] // (ast) => ast\n      // NO REDEX FOUND --> normal form, not expanding M\n      // means - I should signal normal form -- perhaps there is a problem\n      // --> previous step should already be normal form\n      // but this way user finds out this is terminal state only after hitting - next step manually -- possible fix?\n    }\n\n    // debugger\n    // node : AST = parent === null ? newAst\n    //                                                     (to co jsme expandovali)\n    if (parent !== null && treeSide !== null && findRedexIn(expanded, newreduction)) {\n      // REDEX is completely bounded by expanded M Macro expression\n      // console.log(\"_________________________________ rule III. INSIDE EXPANSION\")\n      return [nextReduction, (_) => evaluator.perform()]\n\n      // REDEX belongs to expanded M\n      // --> expand the macro -- so perform the previous macro expansion\n    }\n\n    const beta : Beta = newreduction as Beta\n    if (parent !== null && treeSide !== null // parent and treeSide won't be null --> parent is either APP or Lambda --> they need to parent the macro which was expanded am I right?\n        && parent instanceof Application\n        && parent[treeSide] instanceof Lambda && beta.redex?.left.identifier === parent[treeSide].identifier\n        && newreduction.type === ASTReductionType.BETA\n        && parent.identifier === beta.redex.identifier) {\n      // console.log(\"_________________________________ rule IV. INSIDE\")\n      // rule IV.\n\n      // if ( ! macroIsSingleStep(M)) {\n      //   return [newreduction, newperformevaluation]\n      // }\n\n\n      const expanded : Lambda = parent[treeSide] as Lambda\n      // const [fnArgNames, fnBody] = splitLambdaFn(expanded)\n      // const fnBody : AST = getFnBody(expanded)\n      const fnArgNames : Array<string> = getFnArgNames(expanded)\n      let arity : number = fnArgNames.length\n      const arit : number | null = getArityOfKnownMacro(M.name())\n      if (arit !== null && arit <= arity) {\n        arity = arit\n      }\n      // const arity : number = getArity(expanded)\n      // console.log(\"arity of the macro is: \", arity)\n      // --> get arity of expression X which was expanded from macro M\n      // it should be simple -- just go to the right for the lambda and as long as it's right side is also lambda count +1\n\n\n      const macroAppRedex : MacroBeta =  extendMacroAppRedex(arity, parent, ast)\n      if (strategy === EvaluationStrategy.APPLICATIVE || hasApplicativeOverride(M)) {\n        // console.log(\"............................. MACRO \" + M.name() + \"   has APPLICATIVE OVERRIDE\")\n\n        for (const app of macroAppRedex.applications) {\n          const [argreduction, argperformevaluation] = findSimplifiedReduction(app.right, strategy, macrotable)\n\n          if (argreduction instanceof None) {\n            continue\n          }\n          else {\n            // debugger\n            // we previously expanded our M in the ast\n            // recursive findSimplifiedReduction then works with that\n            // so current app containes M as expanded Expression\n            // we need to take that back\n            \n            return [argreduction, (ast : AST) => {\n              // const newast : AST = argperformevaluation(ast) // original line\n              app.right = argperformevaluation(app.right)\n\n              parent[treeSide] = M\n              // if (newast.identifier !== app.identifier) {\n              //   app.right = newast\n              //   // this is ugly hack but just checking if it works -- it doesn't\n              // }\n              return ast\n            }]\n          }\n        }\n      }\n\n      // kdyz tohle mam hotove OK\n      // musim se podle strategie rozhodnout co budu delat s tim polem applikaci OK\n      // pokud jsem applicative strategy --> musim jit od zacatku pole applikaci OK\n      // a kontrolovat ze app.right je v normalnim tvaru OK\n      // pokud nektery z nich neni - tak jednoduse vezmu ten right -> reknu najdi mi redex a to je to co odsud vratim OK\n      // stejne tak, pokud ma macro applicative override a nektery argument by nebyl normalni tvar OK\n      // jinak pokracuju dal OK\n\n      // return macrobeta reduction as a reduction OK\n      // which is essentially just array of applications OK\n      // also the TOP context needs to check the arity - not just me OK\n      // the performer is just some foreach on the array of betas OK\n\n      \n      // let fnBody : AST = expanded.right\n      // let fn : AST = expanded\n      // const getFnBody = () => (fn as Lambda).right\n      // const setFn = (tree : AST) => fn = tree\n      return [macroAppRedex, (ast) => {\n        // debugger\n        // about SINGLE-STEP:\n        // this function needs to perform all the normalisation if single-step is True\n        // for that reason - I need to remember the last parent of the Extended-REDEX\n        // if that last parent is null --> then it's actually the whole ast\n        // THEN --> after the for loop I need to run another for loop which runs until the last parent is reduced to the normal form\n        // it it's the whole tree/ast --> then it's easier\n        // if it's some sub-tree than it's either APP or ABS\n        // if it's Lambda -> kinda easy --> I can pick this Lambda and normalize it's right side -> then set the result to the original Lambda\n        // it it's APP -> probably same - just need to decide/remember the treeside\n        // for that reason - it would be best to remember also the last app\n        // let's do this now\n        let lastapp : AST | null = null\n        let lastparent : Binary | null = null\n\n        // debugger\n        \n        // budu muset projit kazdou aplikaci v poli\n        // vytvorit pro ni beta redukci pro vyraz ktery vznikl v predchozi iteraci - proto nejde udelat pole beta redukci dopredu\n        // a provest je - na konci vratim vysledny AST\n        for (const app of macroAppRedex.applications) {\n          let appParent : Binary | undefined | null = macroAppRedex.parents.shift() as Binary\n          let treeSide : Child | null = appParent === undefined ? null : appParent.left.identifier === app.identifier ? Child.Left : Child.Right\n          \n          \n\n          \n\n          const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(app) // new NormalEvaluator(app)\n          evaluator.reducer.perform()\n          const reduced : AST = evaluator.reducer.tree\n\n          if (appParent === undefined || treeSide === null) {\n            appParent = null\n            treeSide = null\n            ast = reduced\n            lastapp = ast\n          }\n          else {\n            appParent[treeSide] = reduced\n            lastapp = appParent[treeSide] // what about if the last parent is null?\n            // that means lastapp is going to be something old and wrong right?\n            // maybe it should be ast/reduced\n\n          }\n\n          lastparent = appParent // because I am lazy and don't want to use ifs before the for loop\n\n\n          // let appParent : Binary | undefined | null = macroAppRedex.parents.shift() as Binary\n          // let treeSide : Child | null = appParent === undefined ? null : appParent.left.identifier === app.identifier ? Child.Left : Child.Right\n          \n          // if (appParent === undefined) {\n          //   appParent = null\n          //   treeSide = null\n          // }\n\n          // lastparent = appParent // because I am lazy and don't want to use ifs before the for loop\n          \n          // const argName : string = fnArgNames.shift() as string\n\n          // // if ((app.left as Binary).right === undefined) {\n          // //   debugger\n          // // }\n\n          // const beta : Beta = new Beta(app, appParent as Binary, treeSide, (app.left as Lambda).body , argName, app.right) // getFnBody()\n\n          // // fnBody = (fnBody as Application).right\n          // // setFn(getFnBody())\n\n          // const reducer : BetaReducer = new BetaReducer(beta, ast)\n          // reducer.perform()\n          // ast = reducer.tree\n        }\n\n        if (macroIsSingleStep(M)) {\n          if (lastapp === null) {\n            throw \"This is bad, real bad.\"\n          }\n  \n          if (lastparent === null) {\n            // normalize the whole tree\n            // top-most APP or ABS a result of the Macro-Beta\n  \n            while (true) {\n              const [nextReduction, evaluateReduction] : [ASTReduction, any] =\n                findSimplifiedReduction(ast, strategy, macrotable)\n              \n              if (nextReduction instanceof None) {\n                return tryMacroContraction(ast, macrotable)\n              }\n              else {\n                ast = evaluateReduction(ast)\n              }\n            }\n          }\n          else {\n            const treeSide : Child = lastparent.left.identifier === lastapp.identifier ? Child.Left : Child.Right\n  \n            // debugger\n            while (true) {\n              const [nextReduction, evaluateReduction] : [ASTReduction, any] =\n                findSimplifiedReduction(lastapp as AST, strategy, macrotable)\n  \n              if (nextReduction instanceof None) {\n                lastparent[treeSide] = tryMacroContraction(lastapp as AST, macrotable)\n                return ast\n              }\n              else {\n                lastapp = evaluateReduction(lastapp)\n              }\n            }\n          }\n        }\n        \n\n        return ast // it it's not single-step Macro --> then no contraction I guess\n      }]\n    }\n\n    // THIS IS WRONG --> IT'S NOT NEEDED -- INSTEAD I FIXED RULE III AND IT SHOULD BE ENOUGH\n    // if (newreduction instanceof Expansion) {\n    //   console.log(\"_________________________________ rule V. INSIDE EXPANSION\")\n    //   // Expansion inside Expansion\n    //   // this is for cases --> when one macro needs to expanded because what it expands to is expression ->\n    //   // which leads to another expansion --> because there is some Macro M2 which contains redex for example\n    //   // which means - I need to actually expand \n    //   return [nextReduction, (_) => newAst]\n    // }\n\n    // if (parent !== null && treeSide !== null && ( ! findRedexIn(parent[treeSide], newreduction)))\n    // this is fallbacking action\n    // redex was found - but does not concern previously expanded macro - so the expansions is unnecessary\n    {\n      // console.log(\"_________________________________ rule II. INSIDE THIS IS FALLBACK\")\n      // console.log(newreduction.type)\n\n      // REDEX is NOT inside expanded M -- NOT rule III.\n      // expanded Macro is also not part of the REDEX -- NOT rule IV\n      // --> not expanding M just perform the second reduction but on original tree\n      return [newreduction, (ast) => {\n        const resAST = newperformevaluation(newAst)\n        const p = parent as AST\n        const ts = treeSide as String\n        (p as any)[ts as any] = M\n        // // parent should be not-null\n        // // because if there was a Macro which we were able to Expand\n        // // and then there has been found Redex which is not part of the newly expanded sub-tree\n        // // the new Redex simply has to be in different part of the tree --> which means - M (original Macro) is not the root\n        return resAST\n      }]\n    }\n  }\n  else {\n    // console.log(\"_________________________________ just normal stuff\")\n    return [nextReduction, (ast) => evaluator.perform()]\n\n  // {\n  //   const astCopy : AST = ast.clone()\n  //   const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n    \n  //   if (evaluator.nextReduction instanceof None) {\n  //     isNormal = true\n  //     message = 'Expression is in normal form.'\n      \n  //     reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n  //   }\n\n  //   setBoxState({\n  //     ...state,\n  //     history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ],\n\n  //   })\n  // }\n  }\n}\n\nexport function tryMacroContraction (ast : AST, macrotable : MacroTable) : AST {\n  // compare the ast with all the bulti-in macros\n  // compare the ast with all the user-defined macros\n\n  if (isChurchNumeral(ast)) {\n    const n : number = churchNumeralToNumber(ast as Lambda)\n    const [s, z] : [string, string] = churchArgNames(ast)\n\n    if (n === 0 && s === 's' && z === 'z') {\n      return parse(tokenize(`0`, { lambdaLetters : ['λ'], singleLetterVars : false }), macrotable)\n    }\n    else if (n === 0 && s === 't' && z === 'f') {\n      return parse(tokenize(`F`, { lambdaLetters : ['λ'], singleLetterVars : false }), macrotable)\n    }\n\n    return parse(tokenize(`${n}`, { lambdaLetters : ['λ'], singleLetterVars : false }), macrotable)\n  }\n  \n  for (const [name, definition] of [ ...Object.entries(builtinMacros), ...Object.entries(macrotable) ]) {\n    // parse the definition\n    const tokens : Array<Token> = tokenize(definition, { lambdaLetters : ['λ'], singleLetterVars : false })\n    const macroast : AST = parse(tokens, macrotable)\n\n    const comparator : TreeComparator = new TreeComparator([ast, macroast])\n\n    if (comparator.equals) {\n      const macroNameAst : AST = parse(tokenize(name, { lambdaLetters : ['λ'], singleLetterVars : false }), macrotable)\n\n\n      // const virtualToken : Token = new Token((macroNameAst as Macro).token.type, name, BLANK_POSITION)\n      return macroNameAst // this is dirty-fix -- because the following line somehow produces macro which\n      // expand incorrectly to `undefined` value\n      // return new Macro(virtualToken, macrotable)\n    }\n  }\n\n  return ast\n\n  // for (const macro : )\n}\n\nfunction isChurchNumeral (ast : AST) : boolean {\n  if ( ! (ast instanceof Lambda)) {\n    return false\n  }\n\n  if ( ! (ast.body instanceof Lambda)) {\n    return false\n  }\n\n  return isPeanoNumber(ast.argument.name(), ast.body.argument.name(), ast.body.body)\n}\n\nfunction churchArgNames (ast : AST) : [string, string] {\n  return [(ast as Lambda).argument.name(), ((ast as Lambda).body as Lambda).argument.name()]\n}\n\nfunction isPeanoNumber (s : string, z : string, ast : AST) : boolean {\n  if (ast instanceof Variable && ast.name() === z) {\n    return true\n  }\n\n  if (ast instanceof Application && ast.left.toString() === s) {\n    return isPeanoNumber(s, z, ast.right)\n  }\n\n  return false\n}\n\nfunction churchNumeralToNumber (ast : Lambda) : number {\n  const s : string = ast.argument.name()\n  const z : string = (ast.body as Lambda).argument.name()\n\n  // now for the main hacky stuff\n  const peanoNumber : string = (ast.body as Lambda).body.toString()\n  const matches : RegExpMatchArray | null = peanoNumber.match(RegExp(s, \"g\"))\n  \n  if (matches === null) {\n    return 0\n  }\n  else {\n    return matches.length\n  }\n}\n\n\n\nfunction getArityOfKnownMacro (macroname : string) : number | null {\n  if ([ \"*\", \"+\", \"/\", \"-\", \"^\", \"DELTA\", \"=\", \">\", \"<\", \">=\", \"<=\", \"AND\", \"OR\" ].includes(macroname)) {\n    return 2\n  }\n\n  if ([ \"ZERO\", \"NOT\" ].includes(macroname)) {\n    return 1\n  }\n\n  return null\n}\n\n/**\n * Decides if the result of the application of the macro M to its arguments should evaluate to the normal form\n */\nfunction macroIsSingleStep (macro : Macro) : boolean {\n  if ([ \"*\", \"+\", \"/\", \"-\", \"^\", \"DELTA\", \"=\", \">\", \"<\", \">=\", \"<=\", \"ZERO\", \"NOT\", \"AND\", \"OR\", \"PRED\", \"SUC\" ].includes(macro.name())) {\n    return true\n  }\n\n  // \"T\", \"F\" -- functioning as `if then else` --> therefore can not be Single-Step\n\n  return false\n}\n\n\n// this is basic implementation\n// perhaps Visitor pattern would be better\nfunction findRedexIn (tree : AST, reduction : ASTReduction) : boolean {\n  if (reduction.type === ASTReductionType.ALPHA) {\n    // somehow solve this mess\n    const alpha : Alpha = reduction as Alpha\n\n    if (Array.from(alpha.conversions).some((lambda : Lambda) => tree.identifier === lambda.identifier)) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.BETA) {\n    const beta : Beta = reduction as Beta\n    if (beta.treeSide !== null && beta.parent !== null && tree.identifier === beta.parent[beta.treeSide].identifier) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.ETA) {\n    const eta : Eta = reduction as Eta\n    if (tree.identifier === eta.parent?.identifier) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.EXPANSION) {\n    // debugger\n    const expansion : Expansion = reduction as Expansion\n    if (tree.identifier === expansion.target.identifier) {\n      return true\n    }\n  }\n  else if (reduction.type === ASTReductionType.GAMA) {\n    const macrobeta : MacroBeta = reduction as MacroBeta\n    if (tree.identifier === macrobeta.applications[macrobeta.applications.length - 1].identifier) {\n      return true\n    }\n  }\n\n  if (tree instanceof Application || tree instanceof Lambda) {\n    return findRedexIn(tree.left, reduction) || findRedexIn(tree.right, reduction)\n  }\n  else {\n    return false\n  }\n}\n\n// function getArity (ast : AST) : number { \n//   if (ast instanceof Lambda) {\n//     return 1 + getArity(ast.right)\n//   }\n//   else {\n//     return 0\n//   }\n// }\n\n// function splitLambdaFn (ast : AST) : [Array<string>, AST] {\n//   if (ast instanceof Lambda) {\n//     const [args, body] = splitLambdaFn(ast.right)\n//     return [[ast.left.name(), ...args], body]\n//   }\n//   else {\n//     return [[], ast]\n//   }\n// }\n\nfunction getFnArgNames (ast : AST) : Array<string> {\n  if (ast instanceof Lambda) {\n    return [ast.left.name(), ...getFnArgNames(ast.right)]\n  }\n  else {\n    return []\n  }\n}\n\n\nfunction extendMacroAppRedex (arity : number, basepoint : Application, tree : AST) : MacroBeta {\n  const extender : NormalMacroRedexExtender = new NormalMacroRedexExtender(arity, basepoint, tree)\n\n  return new MacroBeta(extender.applications, extender.parents, arity)\n}\n\nexport class MacroBeta implements ASTReduction {\n  public type : ASTReductionType = ASTReductionType.GAMA\n  constructor (public applications : Array<Application>, public parents : Array<AST>, public arity : number) {}\n}\n\nexport class NormalMacroRedexExtender extends ASTVisitor {\n  public parents : Array<AST> = []  \n  public applications : Array<Application> = []\n\n  private found : boolean = false\n\n  constructor (private arity : number, private basepoint : AST, tree : AST) {\n    super()\n\n    tree.visit(this)\n  }\n\n  onApplication(application : Application): void {\n    if (application.identifier === this.basepoint.identifier) {\n      this.applications.push(application)\n      this.found = true\n      return\n    }\n\n    // go to the left\n    // if found there - I might need to append this application to the list\n    // depending on: is arity bigger than length of list? && is last application in the list the one on the left?\n    // then return\n    application.left.visit(this)\n    if (this.found &&\n      application.left.identifier === this.applications[this.applications.length - 1].identifier) {\n        if (this.arity > this.applications.length) {\n          this.applications.push(application)\n        }\n\n        this.parents.push(application) // pushing this APP as a parent of the previously last one in the list\n        return\n    }\n\n    if (this.found) {\n      return\n    }\n\n    // go to the right\n    // cause it's on the right -> it means this application is definitely not going to the list\n    // so just try to find it there and return\n    application.right.visit(this)\n    if (this.found &&\n      application.right.identifier === this.applications[this.applications.length - 1].identifier) {\n        this.parents.push(application)\n      }\n    return\n  }\n\n  onLambda(lambda : Lambda): void {\n    // lambda definitely interrupts the sequence of APPs\n    // so go find the stuff in the right\n    // but that's all you can do\n    lambda.right.visit(this)\n    if (this.found &&\n      lambda.right.identifier === this.applications[this.applications.length - 1].identifier) {\n        this.parents.push(lambda)\n      }\n    return\n  }\n\n  onChurchNumeral(ChurchNumeral : ChurchNumeral): void {\n    return\n  }\n\n  onMacro(macro : Macro): void {\n    return\n  }\n\n  onVariable(variable : Variable): void {\n    return\n  }\n}\n\nfunction hasApplicativeOverride (macro : Macro) : boolean {\n  // TODO: implement later\n  return [\"*\", \"+\", \"/\", \"-\", \"^\", \"DELTA\", \"=\", \">\", \"<\", \">=\", \"<=\", \"ZERO\", \"NOT\", \"PRED\", \"SUC\"].includes(macro.name())\n  \n  //  \"T\", \"F\"\n  // \"AND\", \"OR\"\n  // return false\n}\n\nexport function strategyToEvaluator (strategy : EvaluationStrategy) : Evaluator {\n  switch (strategy) {\n    case EvaluationStrategy.NORMAL:\n      return NormalEvaluator as any\n \n    case EvaluationStrategy.APPLICATIVE:\n      return ApplicativeEvaluator as any\n\n    case EvaluationStrategy.OPTIMISATION:\n      return OptimizeEvaluator as any\n\n    case EvaluationStrategy.ABSTRACTION: // this will be removed\n      return NormalAbstractionEvaluator as any // this will be removed\n  }\n}","import {  CODE_NAME as UNTYPED_CODE_NAME, decodeUntypedLambdaState, UNTYPED_LAMBDA_INTEGRATION_STATE, createNewUntypedLambdaExpression } from './untyped-lambda-integration/AppTypes'\nimport { defaultSettings as UntypedLambdaDefaultSettings } from './untyped-lambda-integration/AppTypes'\n\nimport { BoxType, Screen, BoxesWhitelist, AppState, GlobalSettings, NotebookState, BoxState } from \"./Types\"\nimport { UntypedLambdaState } from './untyped-lambda-integration/Types'\n\n\nexport const CLEAR_WORKSPACE_CONFIRMATION : string =\n`This will delete this whole Notebook from your browser's memory.\n\n                                          Are you sure?`\n\n// TODO: when building `Exam Mode` simply leave only non-evaluative BoxTypes\nexport const ALL_BOX_TYPES : Array<BoxType> = [ BoxType.UNTYPED_LAMBDA, BoxType.LISP, BoxType.MARKDOWN ]\n\nexport const ANY_BOX = -1\n\nexport const NO_BOX = -2\n\nexport const DEFAULT_WHITELIST : BoxesWhitelist = [ BoxType.UNTYPED_LAMBDA, BoxType.MARKDOWN ]\n\n\nexport function mapBoxTypeToStr (type : BoxType) : string {\n  switch (type) {\n    case BoxType.UNTYPED_LAMBDA:\n      return 'untypedLambdaBox'\n\n    case BoxType.MARKDOWN:\n      return 'markDownBox'\n    default:\n      return ''\n  }\n}\n\nexport const InitNotebookState : NotebookState = {\n  boxList : [],\n  activeBoxIndex : NaN,\n  focusedBoxIndex : undefined,\n  allowedBoxes : DEFAULT_WHITELIST,\n  settings : getDefaultSettings(DEFAULT_WHITELIST),\n  integrationStates : {\n    'UNTYPED_LAMBDA' : UNTYPED_LAMBDA_INTEGRATION_STATE, // TODO: FIX THIS!!!\n  },\n\n  locked : false,\n  menuOpen : false,\n\n  __key : Date.now().toString(),\n  name : \"Default Ntbk\",\n  editingName : false,\n  persistent : true,\n}\n\nexport const HoloNotebookState : NotebookState = {\n  boxList : [ createNewUntypedLambdaExpression(UntypedLambdaDefaultSettings) ],\n  activeBoxIndex : 0,\n  focusedBoxIndex : 0,\n  allowedBoxes : [ BoxType.UNTYPED_LAMBDA],\n  settings : getDefaultSettings([ BoxType.UNTYPED_LAMBDA]),\n  integrationStates : {\n    'UNTYPED_LAMBDA' : UNTYPED_LAMBDA_INTEGRATION_STATE, // TODO: FIX THIS!!!\n  },\n\n  locked : false,\n  menuOpen : false,\n\n  __key : Date.now().toString(),\n  name : \"Holo Notebook\",\n  editingName : false,\n  persistent : true,\n}\n\nexport const EmptyAppState : AppState = {\n  notebookList : [ InitNotebookState ],\n  currentNotebook : 0,\n  currentScreen : Screen.MAIN,\n}\n\nexport const HoloAppState : AppState = {\n  notebookList : [ { ...HoloNotebookState } ],\n  currentNotebook : 0,\n  currentScreen : Screen.MAIN\n}\n\n\nexport function updateSettingsInStorage (settings : GlobalSettings) : void {\n  window.localStorage.setItem('global-settings', JSON.stringify(settings))\n}\n\nexport function getDefaultSettings (whitelist : BoxesWhitelist) : GlobalSettings {\n  let defaultSettings = {}\n\n  if (whitelist === NO_BOX) {\n    whitelist = []\n  }\n  else if (whitelist === ANY_BOX) {\n    whitelist = ALL_BOX_TYPES\n  }\n\n  for (const type of whitelist) {\n    switch (type) {\n      case BoxType.UNTYPED_LAMBDA:\n        defaultSettings = {\n          ...defaultSettings,\n          [UNTYPED_CODE_NAME] : UntypedLambdaDefaultSettings,\n        }\n        break;\n    \n      default:\n        break;\n    }\n  }\n\n  return defaultSettings\n}\n\nexport function loadSettingsFromStorage () : GlobalSettings {\n  const defaultSettings = {\n    [UNTYPED_CODE_NAME] : {}\n  }\n\n  const serialized : string | null = window.localStorage.getItem('global-settings')\n  const deserialized : GlobalSettings =  serialized === null ? defaultSettings : JSON.parse(serialized)\n\n  \n  for (const [key, value] of Object.entries(deserialized)) {\n    switch (key) {\n      case UNTYPED_CODE_NAME:\n        deserialized[key] = { ...UntypedLambdaDefaultSettings, ...value }\n        break;\n    \n      default:\n        console.error(\"Settings CODE NAME is not one of known Code Names.\")\n        break;\n    }\n  }\n\n  return deserialized\n}\n\n\nexport function loadAppStateFromStorage () : AppState {\n  const maybeState : string | null = localStorage.getItem('AppState')\n\n  if (maybeState === null) {\n    localStorage.setItem('AppState', JSON.stringify(EmptyAppState))\n    return EmptyAppState\n  }\n  else {\n    try {\n      return decode(JSON.parse(maybeState))\n    }\n    catch (e) {\n      return EmptyAppState\n    }\n  }\n}\n\nexport function updateAppStateToStorage (state : AppState) : void {\n  localStorage.setItem('AppState', JSON.stringify(state))\n}\n\nexport function updateNotebookStateToStorage (notebook : NotebookState, index : number) {\n  if ( ! notebook.persistent) {\n    return\n  }\n\n  const state : AppState = loadAppStateFromStorage()\n\n  state.notebookList[index] = notebook\n\n  updateAppStateToStorage(state)\n}\n\n// TODO: This function is going to be replaced with correct implementation of decoding\n// this slowly becomes better and better base for the final implementation\n/**\n * This function THROWS Error in case of invalid argument\n * @param state : Deserialized form of AppState\n */\nexport function decode (state : AppState) : AppState | never {\n  const notebookList : Array<NotebookState> = state.notebookList.map(decodeNotebook)\n  \n  return {\n    ...state,\n    notebookList,\n  }\n}\n\nexport function decodeNotebook (notebook : NotebookState) : NotebookState | never {\n  const boxList : Array<BoxState> = notebook.boxList.map((box : BoxState, index : number, arr : Array<BoxState>) => {\n    switch (box.type) {\n      case BoxType.UNTYPED_LAMBDA: {\n        return decodeUntypedLambdaState(box as UntypedLambdaState)\n      }\n\n      //TODO: implement for other Box Types\n    \n      default:\n        return box\n    }\n  })\n\n  return {\n    ...notebook,\n    boxList,\n  }\n}\n\nexport function initIntegrationStates (appState : AppState) {\n  const { currentNotebook, notebookList } : AppState = appState\n  const notebook = notebookList[currentNotebook]\n\n  for (const [key, value] of Object.entries(notebook.integrationStates)) {\n    switch (key) {\n      case BoxType.UNTYPED_LAMBDA: {\n        value.macrotable = UNTYPED_LAMBDA_INTEGRATION_STATE.macrotable  // TODO: this is very informed - should be done by specific integration - leaving just for now\n        return\n      }\n    \n      default:\n        break;\n    }\n  }\n}","import React, { ChangeEvent } from 'react'\n\nimport { AppState, Screen, NotebookState } from '../Types'\n\nimport '../styles/TopBar.css'\nimport { decode, decodeNotebook } from '../AppTypes'\n\n\ninterface Props {\n  state : AppState\n  onImport (notebook : NotebookState) : void\n  onClearWorkspace () : void\n  onScreenChange (screen : Screen) : void\n}\n\nexport default function TopBar (props : Props) : JSX.Element {\n  const { state, onImport, onClearWorkspace, onScreenChange } : Props = props\n  const { currentNotebook, notebookList, currentScreen } : AppState = state\n  const ntbk : NotebookState = notebookList[currentNotebook]\n\n  const { name } : NotebookState = ntbk\n\n  // const dehydrated : object = dehydrate(state)\n\n  const serialized : string = JSON.stringify(ntbk)\n  const link : string = createURL(serialized)\n\n  return (\n    <div className='top-bar'>\n      {/* <div className='cursor-pointer top-bar--notebook-name-container' onClick={ () => onScreenChange(Screen.MAIN) } >\n        <span className='top-bar--notebook-name'>\n          { name }\n        </span>\n      </div> */}\n\n      <span className='top-bar--item-container'>\n        {/* SETTINGS */}\n        {/* <span\n          className={ currentScreen === Screen.SETTINGS ? 'top-bar--item top-bar--item-hoverable top-bar--item-hoverable--active' : 'top-bar--item top-bar--item-hoverable' }\n          title='Go to the Settings'\n          onClick={ () => {\n            if (currentScreen === Screen.SETTINGS) {\n              onScreenChange(Screen.MAIN)\n            }\n            else {\n              onScreenChange(Screen.SETTINGS)\n            }\n          } }\n        >\n          <i\n            className=\"top-icon fas fa-cogs\"\n          />\n          <p className='top-bar--icon-label'>Settings</p>\n        </span> */}\n\n        {/* Clear the Whole Workspace */}\n        <span\n          className='top-bar--item top-bar--item-hoverable'\n          title='Clear the Whole Workspace'\n          onClick={ onClearWorkspace }\n        >\n          <i\n            className=\"top-icon fas fa-eraser\"\n          />\n          <p className='top-bar--icon-label'>Clear All</p>\n        </span>\n\n        {/* Export Notebook */}\n        \n        {/* <a\n          className='export'\n          href={ link }\n          download=\"notebook_lambdulus.lus\" // TODO: change the name according to the notebook name\n          onClick={ () => setTimeout(() => {\n            // window.URL.revokeObjectURL(link)\n            // TODO: I shouldn't NOT do this - but if I revoke I can't click it again without re-render\n\n            // reportEvent('Export notebook', `Notebook: ${serialized}`, '') // TODO: report event\n          }, 10) }\n        >\n          <span\n            className='top-bar--item top-bar--item-hoverable'\n            title='Download this Notebook'\n          >\n            <i id='download' className=\"top-icon fas fa-cloud-download-alt\" />\n          \n          <p className='top-bar--icon-label'>Export</p>\n          </span>\n        </a> */}\n\n        {/* Import Notebook */}\n        {/* <input type=\"file\" accept=\".lus\" id=\"input\"\n          onChange={ (e) => onFiles(e, onImport) }\n        />\n        <label htmlFor=\"input\">\n          <span\n            className='top-bar--item top-bar--item-hoverable'\n            title='Import a Notebook from Computer'\n          >\n            <i className=\"top-icon fas fa-cloud-upload-alt\" />\n            <p className='top-bar--icon-label'>Import</p>\n          </span>\n        </label> */}\n      </span>\n    </div>\n  )\n}\n\nfunction onFiles (event : ChangeEvent<HTMLInputElement>, onImport : (notebook : NotebookState) => void) : void {\n  const { target : { files } } = event\n  if (files === null) {\n    return\n  }\n\n  const file : File = files[0]\n  const reader : FileReader = new FileReader\n  reader.onload = (event : Event) => {\n    const notebook : NotebookState = JSON.parse(reader.result as string)\n\n    onImport(decodeNotebook(notebook))\n\n    // onImport(hydrate(state))\n    // reportEvent('Import notebook', `Notebook named ${ file.name }`, '')\n  }\n\n  reader.readAsText(file) \n}\n\nfunction createURL (content : string) : string {\n  const data = new Blob([ content ], {\n    type: 'application/json'\n  })\n\n  return window.URL.createObjectURL(data);\n}","import React, { ChangeEvent } from 'react'\n\nimport { decode } from '../AppTypes'\nimport { Screen, AppState } from '../Types'\n\n\nimport '../styles/MenuBar.css'\n// import { reportEvent } from '../misc'; // later\n\ninterface MenuBarProperties {\n  state : AppState\n  // onImport (state : AppState) : void\n  // onClearWorkspace () : void\n  onScreenChange (screen : Screen) : void\n}\n\nexport default function MenuBar (props : MenuBarProperties) : JSX.Element {\n  const { state, onScreenChange } : MenuBarProperties = props\n\n  const { currentScreen } = state\n\n  return (\n    <div id=\"menu-bar\">\n      <div\n        className='tab'\n        title='Get Info about this Tool'\n        onClick={ () => void 0 }\n      >\n        <span className='lambdulusIcon'>λ</span>\n        <p className='iconLabel'>Lambdulus</p>\n      </div>\n\n      {/* <div className='separator' /> */}\n\n      {/* NOTEBOOK */}\n      {/* <div\n        className={ currentScreen === Screen.NOTEBOOKS ? 'currentTab tab tab-hoverable' : 'tab tab-hoverable' }\n        title='Show All Notebooks'\n        onClick={ () => onScreenChange(Screen.NOTEBOOKS) }\n      >\n        <i\n          // className=\"icon far fa-file-alt\"\n          className=\"icon far fa-copy\"\n        />\n        <p className='iconLabel'>Notebooks</p>\n      </div> */}\n\n      <div className='menu-bar--bottom-part'>\n        {/* Issues */}\n        <div\n          className='tab tab-hoverable'\n          title='Submit a Bug or a Feature Request'\n        >\n          <a\n          target=\"_blank\"\n            href='https://github.com/lambdulus/holo/issues'\n          >\n            <i className=\"icon fas fa-bug\" />\n          </a>\n          <p className='iconLabel'>GH Issues</p>\n        </div>\n\n        {/* MANUAL/HELP */}\n        <div\n          className={ currentScreen === Screen.HELP ? 'currentTab tab tab-hoverable' : 'tab tab-hoverable' }\n          title={ currentScreen === Screen.MAIN ? 'Show the Manual' : 'Go back' }\n          onClick={ () => {\n            if (currentScreen === Screen.HELP) {\n              onScreenChange(Screen.MAIN)\n            }\n            else {\n              onScreenChange(Screen.HELP)\n            }\n          }}\n        >\n          <i\n            className=\"icon far fa-question-circle\"\n          />\n          <p className='iconLabel'>Manual</p>\n        </div>\n      </div>\n\n\n    </div>\n  )\n}\n\n// function dehydrateBox (box : BoxState) : BoxState {\n//   const { type } : BoxState = box\n\n//   if (type === BoxType.EXPRESSION) {\n\n//     return {\n//       ...box,\n//       ast : null as any, // TODO: don't\n//       history : [], // TODO: don't\n//       isRunning : false,\n//       breakpoints : [], // TODO: solve how to don't\n//       timeoutID : undefined,\n//     }\n//   }\n\n//   return box\n// }\n\n// function dehydrate (state : AppState) : AppState {\n//   return {\n//     ...state,\n//     submittedBoxes : state.submittedBoxes.map(dehydrateBox)\n//   }\n// }\n\n// function hydrateBox (box : BoxState, macroTable : MacroMap) : BoxState {\n//   const { type } : BoxState = box\n  \n//   if (type === BoxType.EXPRESSION) {\n//     const { singleLetterNames } = box as UntypedLambdaState\n//     const ast : AST = parseExpression((box as UntypedLambdaState).expression, { macroTable, singleLetterNames })\n\n//     return {\n//       ...box,\n//       ast,\n//       history : [ { ast, lastReduction : None, step : 0, message : '', isNormalForm : false } ],\n//     }\n//   }\n\n//   return box\n// }\n\n// function hydrate (dehydrated : AppState) : AppState {\n//   const { macroTable } = dehydrated\n//   const config = { macroTable }\n\n//   return {\n//     ...dehydrated,\n//     submittedBoxes : dehydrated.submittedBoxes.map((box) => hydrateBox(box, macroTable))\n//   }\n// }\n\n// interface Config {\n//   singleLetterNames : boolean\n//   macroTable : MacroMap\n// }\n\n// function parseExpression (expression : string, config : Config) : AST {\n//   const { singleLetterNames : singleLetterVars, macroTable } : Config = config\n  \n//   const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars })\n//   const ast : AST = parse(tokens, macroTable)\n\n//   return ast\n// }","import { BoxType, AbstractBoxState } from \"../Types\"\n\n\nexport interface NoteState extends AbstractBoxState {\n  __key : string\n  type : BoxType\n  note : string\n  isEditing : boolean\n  editor : {\n    placeholder : string\n    content : string\n    caretPosition : number\n    syntaxError : Error | null\n  }\n}\n\nexport function createNewMarkdown () : NoteState {\n  return {\n    __key : Date.now().toString(),\n    type : BoxType.MARKDOWN,\n    title : 'Markdown Box',\n    minimized : false,\n    menuOpen : false,\n    settingsOpen : false,\n    note : '',\n    isEditing : true,\n    editor : {\n      placeholder : PromptPlaceholder,\n      content : '',\n      caretPosition : 0,\n      syntaxError : null\n    }\n  }\n}\n\nexport function resetMarkdownBox (state : NoteState) : NoteState {\n  return {\n    ...state,\n    minimized : false,\n    note : '',\n    isEditing : true,\n    editor : {\n      placeholder : PromptPlaceholder,\n      content : '',\n      caretPosition : 0,\n      syntaxError : null\n    }\n  }\n}\n\nexport const PromptPlaceholder : string = 'Note in MarkDown'\n\nexport function onMarkDownBlur (state : NoteState) : NoteState {\n  return {\n    ...state,\n    isEditing: false,\n  }\n}\n\nexport function onMarkDownActive (state : NoteState) : NoteState {\n  return {\n    ...state,\n    isEditing : true,\n  }\n}","import React from 'react'\nimport { GlobalSettings, BoxesWhitelist, BoxState, BoxType } from '../Types'\nimport { createNewMarkdown } from '../markdown-integration/AppTypes'\nimport { UntypedLambdaSettings, UntypedLambdaState } from '../untyped-lambda-integration/Types'\nimport { createNewUntypedLambdaExpression, ADD_BOX_LABEL, CODE_NAME as UNTYPED_CODE_NAME } from '../untyped-lambda-integration/AppTypes'\nimport { ANY_BOX, NO_BOX } from '../AppTypes'\n\n\nimport '../styles/PickBoxTypeModal.css'\n\n\nfunction anyBoxAllowed (whitelist : BoxesWhitelist) : boolean {\n  return whitelist === ANY_BOX\n}\n\nfunction noBoxAllowed (whitelist : BoxesWhitelist) : boolean {\n  return whitelist === NO_BOX\n}\n\nfunction isAllowed (type : BoxType, whitelist : BoxesWhitelist) : boolean {\n  return anyBoxAllowed(whitelist) || (whitelist as Array<BoxType>).includes(type)\n}\n\ninterface Props {\n  addNew (box : BoxState) : void\n  whiteList : BoxesWhitelist\n  settings : GlobalSettings\n}\n\n\nexport default function PickBoxTypeModal (props : Props) : JSX.Element {\n  const { addNew, whiteList, settings } : Props = props\n\n  const untLSettings : UntypedLambdaSettings = settings[UNTYPED_CODE_NAME] as UntypedLambdaState\n\n  const addLambdaBoxIfAllowed = (allowed : boolean) => (\n    allowed ?\n      <div className='add-box--group'>\n        <div\n          className='plusBtn'\n          title='Create new λ box'\n          onClick={ (e) => {\n            e.stopPropagation()\n            // this.setState({ opened : false })\n            addNew(createNewUntypedLambdaExpression(untLSettings)) }\n          }\n        >\n          <p className='create-box--big'>λ</p>\n          <p className='creat-box--label'>{ ADD_BOX_LABEL }</p>\n        </div>\n      </div>\n      :\n      null\n  )\n\n  const addLispBoxIfAllowed = (allowed : boolean) => (\n    allowed ?\n      <div className='add-box--group'>\n        <div\n          className='plusBtn'\n          title='Create new Lisp box'\n          onClick={ (e) => {\n            e.stopPropagation()\n            // this.setState({ opened : false })\n            addNew({__key : Date.now().toString()} as BoxState) } // NOTE: just for now\n          }\n        >\n          <p className='create-box--big'>()</p>\n          <p className='creat-box--label'>+ Lisp</p>\n        </div>\n      </div>\n      :\n      null\n  )\n\n  const addMDBoxIfAllowed = (allowed : boolean) => (\n    allowed ?\n    <div className='add-box--group'>\n      <div\n        className='plusBtn'\n        title='Create new MarkDown box'\n        onClick={ (e) => {\n          e.stopPropagation()\n          // this.setState({ opened : false })\n          addNew(createNewMarkdown()) }\n        }\n      >\n        <p className='create-box--big'>M&darr;</p>\n        <p className='creat-box--label'>+ Markdown</p>\n      </div>\n    </div>\n    :\n    null\n  )\n\n  return (\n    <div className='box-top-bar--modal--pick-box-type'>\n      {\n        noBoxAllowed(whiteList) ?\n          <h4>No Boxes Allowed</h4>\n          :\n          <div\n            className='modal--create-box'\n          >\n            <div className='modal--create-box--container'>\n              { addLambdaBoxIfAllowed(isAllowed (BoxType.UNTYPED_LAMBDA, whiteList)) }\n              { addLispBoxIfAllowed(isAllowed(BoxType.LISP, whiteList)) }\n              { addMDBoxIfAllowed(isAllowed(BoxType.MARKDOWN, whiteList)) }\n            </div>\n          </div>\n      }\n    </div>\n  )\n}","import React, { Component } from 'react'\n\nimport { ANY_BOX, NO_BOX } from '../AppTypes'\nimport { BoxType, BoxesWhitelist, BoxState, GlobalSettings } from '../Types'\nimport { createNewUntypedLambdaExpression, ADD_BOX_LABEL, CODE_NAME as UNTYPED_CODE_NAME } from '../untyped-lambda-integration/AppTypes'\nimport { UntypedLambdaSettings, UntypedLambdaState } from '../untyped-lambda-integration/Types'\nimport { createNewMarkdown } from '../markdown-integration/AppTypes'\n\nimport \"../styles/CreateBox.css\"\nimport PickBoxTypeModal from './PickBoxTypeModal'\n\ninterface Props {\n  addNew : (box : BoxState) => void\n  whiteList : BoxesWhitelist\n  settings : GlobalSettings\n}\n\ninterface State {\n  modalOpen : boolean\n}\n\n// TODO: this needs to change\n// somehow I need to be able to delegate choosing the specific subtype of the Box\nexport default class CreateBox extends Component <Props, State> {\n  constructor (props : Props) {\n    super(props)\n\n    this.state = {\n      modalOpen : false\n    }\n  }\n\n  render () : JSX.Element {\n    const { addNew, whiteList, settings } : Props = this.props\n    const { modalOpen } = this.state\n\n    const untLSettings : UntypedLambdaSettings = settings[UNTYPED_CODE_NAME] as UntypedLambdaState\n   \n    if (this.state.modalOpen === false) {\n      return (\n        <div className='create-box-plus' onClick={ () => {\n          // this.setState({ modalOpen : ! modalOpen })\n          addNew(createNewUntypedLambdaExpression(untLSettings))\n          }} >\n          <div className='create-box-plus--button'>\n            {/* <div className='create-box-plus--container' onClick={ () => {} }> */}\n              {/* <p> */}\n                <i className=\"fas fa-plus\" />\n              {/* </p> */}\n            {/* </div> */}\n          </div>\n        </div>\n      )\n    }\n    else {\n      return (\n        <PickBoxTypeModal\n          addNew={ (box : BoxState) => {\n            addNew(box)\n            this.setState({ modalOpen : false })\n          } }\n          whiteList={ this.props.whiteList }\n          settings={ this.props.settings }\n        />\n      )\n    }\n  }\n}\n  \n","import React from 'react'\n\nimport { ASTVisitor, Lambda, Variable, Beta, AST, Application, ChurchNumeral, Expansion, Macro, ASTReduction, Alpha, Gama, ASTReductionType } from \"@lambdulus/core\"\nimport { Breakpoint } from './Types'\nimport { reportEvent } from '../misc';\nimport { MacroBeta } from './AppTypes';\n\n\nexport default class ReactPrinter extends ASTVisitor {\n  private rendered : JSX.Element | null = null\n  private argument : Variable | null = null\n\n  // TODO: this is just temporary and very dirty hot fix\n  // because findSimplifiedReduction needs to get clonned tree\n  // because it modifies that tree even thought it probably shoudl not\n  // actual tree being printed is not the same\n  // this then leads to some problem when expression is being copied (argument used mutliple times inside lambda)\n  // and one of them is then identified as a REDEX\n  // because all of them share same Identifier --> all of them are identified as a redex\n  // private foundRedexes : Array<symbol> = []\n  // on the other hand -- this is not so dirty right?\n  private redexesFound : number = 0 // 0 is empty ; 1 is found ; -1 is blocked and can't be set to 1 again\n  // NOW: be very careful\n  // this solution unfortunately combines both of the original solutions and this means it probably takes\n  // the worst of both of them\n  // what it means is this:\n  // it relies on correct logic that sets reduction.topLevelParent\n  // there could very well be bug and it could work badly\n  // also it relies on order\n  // once the redexFound was set to 1 it will be set to -1 and then it cannot be set again\n  // this means - I efectively say - only first occurence of the expression can be the REDEX\n  // be very aware that this might be very ill and really buggy\n  //\n  //\n  // final decision is to dith all of the above\n  // and just go with counting --> logic seems sound --> if I arrive somewhere first when printing\n  // in the same order I look for the redexes (in normal order at least I hope) --> it should be redex\n  // rest is fake\n\n  private printMultiLambda (lambda : Lambda, accumulator : JSX.Element) : void {\n    if (lambda.body instanceof Lambda) {\n      const context : Variable = lambda.body.argument\n      let className : string = 'argument'\n      let title : string = ''\n\n      if (this.isBreakpoint(lambda.body.argument)) {\n        className += ' breakpoint'\n        title = 'Will break on substitution'\n      }\n\n      // bug@highlight-alpha\n      let set = false\n      if (this.reduction instanceof Alpha\n            &&\n          Array.from(this.reduction.conversions).some((conversion : Lambda) => {\n            return conversion.identifier === lambda.body.identifier\n          })\n          ) {\n              this.argument = context\n              set = true\n              className += ' alpha'\n      }\n\n      // TO JE KVULI FIXU MULTILAMBDA FACCT 3 beta redukce nad shadowingem\n      let argument : Variable | null = this.argument\n      if (this.argument !== lambda.body.argument\n          &&\n          this.argument !== null\n          &&\n          this.argument.name() === lambda.body.argument.name()) {\n        this.argument = null\n      } // TO JE KVULI FIXU MULTILAMBDA FACCT 3 beta redukce nad shadowingem\n\n      // TODO: same here\n      if (this.argument\n          &&\n          this.argument.name() === context.name()) {\n            className += ' substitutedArg'\n        }\n\n      const args : JSX.Element = (\n        <span className='arguments'>\n          { accumulator } {' '}\n          <span\n            className={ className }\n            title={ title }\n            onClick={ () => {\n              (context as any).identifier = Symbol()\n              this.onClick({ type : ASTReductionType.BETA, context, broken : new Set })\n              reportEvent('Breakpoint added to argument', 'Breakpoint was added', '')\n            }\n            }\n          >\n            { context.name() }\n          </span>\n        </span>\n      )\n      \n      this.printMultiLambda(lambda.body, args)\n      if (set === true) {\n        this.argument = null\n      }\n      this.argument = argument // TO JE KVULI FIXU MULTILAMBDA FACCT 3 beta redukce nad shadowingem\n    }\n    else {\n      lambda.body.visit(this)\n      const body : JSX.Element | null = this.rendered\n      this.rendered = accumulator\n\n      this.rendered = (\n        <span className='function'>\n          (\n          <span\n            className='lambda'\n            >\n              λ { ' ' }\n          </span>\n          { accumulator } . { body }\n          )\n        </span>\n      )\n    }\n  }\n\n  isBreakpoint (node : AST) : boolean {\n    for (const breakpoint of this.breakpoints) {\n      if (breakpoint.context.identifier === node.identifier) {\n        return true\n      }\n    }\n    return false\n  }\n\n  constructor (\n    public readonly tree : AST,\n    private readonly onClick : (breakpoint : Breakpoint) => void,\n    private readonly reduction : ASTReduction,\n    private readonly breakpoints : Array<Breakpoint>,\n    private readonly SDE : boolean,\n  ) {\n    super()\n    this.tree.visit(this)\n  }\n\n  print () : JSX.Element | null {\n    return this.rendered\n  }\n\n  // TODO: little bit refactored, maybe keep going\n  onApplication (application: Application) : void {\n    let className : string = 'application'\n    let leftClassName : string = 'left'\n    let rightClassName : string = 'right'\n    let set : boolean = false\n    let redex : AST | null = null\n\n    if (this.reduction instanceof Beta) {\n      redex = this.reduction.redex\n    }\n\n    if (this.reduction instanceof MacroBeta) {\n      // if (this.redexFound === 0 && application.identifier === this.reduction.topLevelParent.identifier) {\n      //   this.redexFound = 1\n      //   redexFoundFlag = true\n      //   debugger\n      // }\n      \n      //  === 1 && \n      if (this.redexesFound < this.reduction.arity && this.reduction.applications.some((app : Application) => app.identifier === application.identifier)) {\n        if (application.left instanceof Macro) {\n          leftClassName += ' extended-redex'\n        }\n\n        this.redexesFound++\n        \n        rightClassName += ' extended-redex'\n        // console.log('bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb')\n      }\n    }\n\n    if (this.reduction instanceof Gama && this.reduction.args.includes(application)) {\n      className += ' redex abstraction argument'\n    }\n\n    // else if (this.reduction instanceof Expansion) {\n    //   redex = this.reduction.target\n    // } // to asi neni uplne potreba tady\n\n    if (redex !== null\n          &&\n        redex.identifier === application.identifier // tohle je asi trosku useles\n          &&\n        redex === application\n      ) {\n        leftClassName += ' redex'\n        rightClassName += ' redex'\n\n        // TODO: this is probably not good and should be done other way\n\n        if (application.left instanceof Lambda) {\n          this.argument = application.left.argument\n          set = true\n        }\n    }\n\n    if (application.right instanceof Application) {\n      application.left.visit(this)\n      const left : JSX.Element | null = <span className={ leftClassName }>{this.rendered}</span>\n\n      // tohle delam proto, ze se nesmi vypnout this.argument u libovolne aplikace, jenom u te ktera ho setnula\n      // priklad + 2 3 a krokuj - zakomentuj a krokuj znovu Y se bude chovat spatne hned v prvnich krocich\n      if (set) {\n        this.argument = null\n      }\n\n      application.right.visit(this)\n      const right : JSX.Element | null = <span className={ rightClassName }>( { this.rendered } )</span>\n\n      this.rendered =\n      <span className={ className }>\n        { left } { right }\n      </span>\n    }\n    else {\n      application.left.visit(this)\n      const left : JSX.Element | null = <span className={ leftClassName }>{this.rendered}</span>\n\n      // tohle delam proto, ze se nesmi vypnout this.argument u libovolne aplikace, jenom u te ktera ho setnula\n      // priklad + 2 3a krokuj - zakomentuj a krokuj znovu Y se bude chovat spatne hned v prvnich krocich\n      if (set) {\n        this.argument = null\n      }\n\n      application.right.visit(this)\n      const right : JSX.Element | null = <span className={ rightClassName }>{ this.rendered }</span>\n\n      this.rendered =\n      <span className={ className }>\n        { left } { right }\n      </span>\n    }\n  }\n  \n  // TODO: little bit refactored, maybe keep going\n  onLambda (lambda: Lambda) : void {\n    // TODO: this also seems not so elegant and clean\n\n    let title : string = ''\n\n    let argument : Variable | null = this.argument\n    if (this.argument !== lambda.argument\n        &&\n        this.argument !== null\n        &&\n        this.argument.name() === lambda.argument.name()) {\n      this.argument = null\n    }\n\n\n    // multilambda\n    if (lambda.body instanceof Lambda) {\n      const context : Variable = lambda.argument\n      let className : string = 'argument'\n\n      if (this.isBreakpoint(lambda.argument)) {\n        className += ' breakpoint'\n        title = 'Will break on substitution'\n      }\n\n      // TODO: same here\n      if (this.argument\n        &&\n        this.argument.name() === context.name()) {\n          className += ' substitutedArg'\n      }\n\n      // if (this.reduction instanceof Alpha) {\n      //   className += ' alpha'\n      // }\n\n      const acc : JSX.Element = (\n        <span\n          className={ className }\n          title={ title }\n          onClick={ () => {\n            (context as any).identifier = Symbol()\n            this.onClick({ type : ASTReductionType.BETA, context, broken : new Set })\n            reportEvent('Breakpoint added to argument', 'Breakpoint was added', '')\n          }\n          }\n        >{ lambda.argument.name() }\n        </span>\n      )\n\n      this.printMultiLambda(lambda, acc)\n    }\n    else {\n      const context : Variable = lambda.argument\n\n      // lambda.argument.visit(this)\n      \n      // const args : JSX.Element | null = this.rendered\n\n      lambda.body.visit(this)\n      const body : JSX.Element | null = this.rendered\n\n      let className : string = 'argument'\n      let title : string = ''\n\n      if (this.isBreakpoint(lambda.argument)) {\n        className += ' breakpoint'\n        title = 'Will break on substitution'\n      }\n\n      // TODO: same here\n      if (this.argument\n        &&\n        this.argument.name() === context.name()) {\n          className += ' substitutedArg'\n      }\n\n      this.rendered = (\n        <span className='function' >\n          (\n          <span\n            className='lambda'\n            >\n              λ { ' ' }\n          </span>\n          <span\n            className='arguments'\n            onClick={ () => {\n              (context as any).identifier = Symbol()\n              // TODO: for now it does nothing - maybe delete in the future            \n              // this.onClick({ type : Beta, context, broken : new Set })\n              // reportEvent('Breakpoint added to argument', 'Breakpoint was added', '')\n            }\n            }\n          >\n            <span\n                className={ className }\n                title={ title }\n                onClick={ () => {\n                  (context as any).identifier = Symbol()\n                  this.onClick({ type : ASTReductionType.BETA, context, broken : new Set })\n                  reportEvent('Breakpoint added', 'Breakpoint was added', '')\n                }\n                }\n            >\n              { lambda.argument.name() }\n            </span>\n            { ' ' }\n          </span>\n          . { body } \n          )\n        </span>\n      )\n    }\n\n    this.argument = argument\n    if (argument !== null) {\n      this.argument = argument\n    }\n  }\n  \n  // TODO: little bit refactored, maybe keep going\n  onChurchNumeral (churchNumber: ChurchNumeral) : void {\n    let className : string = 'churchnumeral'\n    let redex : AST | null = null\n    let redexClass : string = ' redex'\n    let title : string = ''\n\n    if (this.reduction instanceof Expansion) {\n      redex = this.reduction.target\n    }\n\n    if (this.reduction instanceof Gama && this.reduction.args.includes(churchNumber)) {\n      className += ' redex abstraction argument'\n    }\n\n    if (redex !== null\n          &&\n        redex.identifier === churchNumber.identifier\n          &&\n        redex === churchNumber\n      ) {\n        className += redexClass\n    }\n\n    if (this.isBreakpoint(churchNumber)) {\n      className += ' breakpoint'\n      title = 'Will break on Expansion'\n    }\n\n    this.rendered = (\n      <span\n        className={ className }\n        title={ title }\n        onClick={ () => {\n          (churchNumber as any).identifier = Symbol()\n          this.onClick({ type: ASTReductionType.EXPANSION, context : churchNumber, broken : new Set })\n          reportEvent('Breakpoint added to ChurchNumeral', 'Breakpoint was added', '')\n        }\n        }\n      >\n        { churchNumber.name() }\n      </span>\n    )\n  }\n\n  // TODO: little bit refactored, maybe keep going  \n  onMacro (macro: Macro) : void {\n    // console.log(this.reduction)\n    let className = 'macro'\n    let redex : AST | null = null\n    let redexClass : string = ' redex'\n    let title : string = ''\n\n    if (this.reduction instanceof Expansion) {\n      redex = this.reduction.target\n    }\n\n    if (this.reduction instanceof Gama) {\n      if (this.reduction.redexes.includes(macro)) {\n        [ redex ] = this.reduction.redexes\n        className += redexClass + ' abstraction'\n      }\n\n\n      if (this.reduction.args.includes(macro)) {\n        className += redexClass + ' abstraction argument'\n      }\n    }\n\n    if (this.reduction instanceof MacroBeta) {\n      \n      if (macro.identifier === this.reduction.applications[0].left.identifier) {\n        className += ' abstraction'\n        // console.log('............................................------------------.................................')\n      }\n      // console.log(\"MMMMMMMMMMMMMMMMACROBEEEEEEEEEEEEEEEEEEEEEETAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")\n\n    }\n\n\n    if (redex !== null\n          &&\n        redex.identifier === macro.identifier\n          &&\n        redex === macro\n        ) {\n      className += redexClass\n    }\n\n    if (this.isBreakpoint(macro)) {\n      className += ' breakpoint'\n      title = 'Will break on Expansion'\n    }\n\n    this.rendered = (\n      <span\n        className={ className }\n        title={ title }\n        onClick={ () => {\n          (macro as any).identifier = Symbol()\n          this.onClick({ type: ASTReductionType.EXPANSION, context : macro, broken : new Set })\n          reportEvent('Breakpoint added to Macro', 'Breakpoint was added', '')\n        }\n        }\n      >\n        { macro.name() }\n      </span>\n    )\n  }\n  \n  onVariable (variable: Variable): void {\n    // TODO: same here - not so clean\n    let className : string = 'variable'\n\n    if (this.argument\n        &&\n        this.argument.name() === variable.name()) {\n          className += ' substitutedArg'\n          if (this.reduction instanceof Alpha) {\n            className += ' alpha'\n          }\n      }\n\n    this.rendered = <span className={ className } >{ variable.name() }</span>\n  }\n}","import React from 'react'\nimport { ASTReduction, Beta, Alpha, Expansion, Gama, ASTReductionType } from '@lambdulus/core' // , Eta\n\n\ninterface ReductionMessageProperties {\n  lastReduction : ASTReduction | null\n}\n\nexport default function ReductionMessage (props : ReductionMessageProperties) : JSX.Element {\n  const { lastReduction } = props\n\n  if (lastReduction === null) {\n    return null as any\n  }\n\n  if (lastReduction.type === ASTReductionType.BETA) {\n    return (\n      <p className='lastReduction'>\n        β reduction\n      </p>\n    )\n  }\n\n  if (lastReduction.type === ASTReductionType.ALPHA) {\n    return (\n      <p className='lastReduction'>\n        α conversion\n      </p>\n    )\n  }\n\n  if (lastReduction.type === ASTReductionType.EXPANSION) {\n    return (\n      <p className='lastReduction'>\n        Macro expansion\n      </p>\n    )\n  }\n\n  // if (lastReduction.type === ASTReductionType.ETA) {\n  //   return (\n  //     <p className='lastReduction'>\n  //       η conversion\n  //     </p>\n  //   )\n  // }\n\n  if (lastReduction.type === ASTReductionType.GAMA) {\n    return (\n      <p className='lastReduction'>\n        Simplified Beta Reduction\n      </p>\n    )\n  }\n\n  else {\n    return null as any\n  }\n  \n}","import React, { memo } from 'react'\nimport { ASTReduction, AST, MacroMap, None } from '@lambdulus/core'\n\nimport './styles/Step.css'\n\nimport ReactPrinter from './ReactPrinter'\n// import ReductionMessage from './ReductionMessage'\nimport { EvaluationStrategy, StepRecord, Breakpoint, Evaluator } from './Types'\nimport ReductionMessage from './ReductionMessage'\nimport { strategyToEvaluator, findSimplifiedReduction, MacroBeta } from './AppTypes'\n// import { StrategyContext } from './DataInjector'\n\n\ninterface StepWrapperProperties {\n  stepRecord : StepRecord\n  breakpoints : Array<Breakpoint>\n  strategy : EvaluationStrategy\n  addBreakpoint (breakpoint : Breakpoint) : void\n  children : JSX.Element\n  lastStep : boolean\n  SDE : boolean\n  macrotable : MacroMap\n}\n\ninterface StepProperties {\n  stepRecord : StepRecord\n  breakpoints : Array<Breakpoint>\n  addBreakpoint (breakpoint : Breakpoint) : void\n  children : JSX.Element\n  strategy : EvaluationStrategy\n  lastStep : boolean\n  SDE : boolean\n  macrotable : MacroMap\n}\n\n// This is done because of highlighting - if Strategy is changed ->\n// old steps should not be re-highlighted with changed Strategy - but stay same\nconst StepMemo = memo(Step, (props : StepProperties) => !props.lastStep)\n\nexport default function StepWrapper (props : StepWrapperProperties) : JSX.Element {\n  // return(\n  //   <StrategyContext.Consumer>\n  //     { \n  //       (strategy : EvaluationStrategy) => <StepMemo { ...props } strategy={ strategy } />\n  //     }\n  //   </StrategyContext.Consumer>\n  // )\n  return(\n    <StepMemo { ...props } />\n  )\n}\n\nfunction Step (props : StepProperties) : JSX.Element | null {\n  const { stepRecord, addBreakpoint, breakpoints, children, strategy, SDE, macrotable } = props\n  const { ast : tree, lastReduction, step, message } = stepRecord\n\n  if (tree === null) {\n    return null\n  }\n\n  // const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(tree)\n  const newast : AST = tree.clone()\n  let nextReduction = (() => {\n    if (SDE) {\n      return findSimplifiedReduction(newast, strategy, macrotable)[0]\n    }\n    else {\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(tree)\n      return evaluator.nextReduction\n    }\n  })()\n\n  if ( ! (nextReduction instanceof MacroBeta) && !(nextReduction instanceof None)) {\n    // TODO: read carefully\n    // this means -- next reduction is gonna be normal stuff (Beta, Alpha, Expansion)\n    // because of some decision to structure the findSimplifiedReduction the way it works\n    // mainly := first clone the tree and then mutate it with each recursive call\n    // if it's the normal stuff --> then the tree I used to identify the redex is not the same tree as I am giving to the ReactPrinter\n    // for this reason I have to use redex finder which does not mutate the tree under my hands at least until I rewrite\n    // the findSimplifiedReduction\n    const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(tree)\n    nextReduction = evaluator.nextReduction\n    // TODO: read carefully\n    // this definitely needs to be fixed\n    // I will most certainly need to do some dirty magic in ReactPrinter - because this design also makes it impossible\n    // to decide what is current redex in expressions like:\n    // (λ x . + x x) ( + 1 2 )\n    // + [( + 1 2 )] [( + 1 2 )]\n    // both [( + 1 2 )] are highlighted\n    // but maybe its not related to this\n  }\n  const reduction : ASTReduction = nextReduction\n  const printer : ReactPrinter = new ReactPrinter(tree, addBreakpoint, reduction, breakpoints, SDE)\n\n  const incorrectStep : boolean = stepRecord.message.indexOf('Incorrect step.') === 0\n  const correctStep : boolean = stepRecord.message.indexOf('Correct.') === 0\n  const exerciseStep : boolean = incorrectStep || correctStep\n\n  return (\n    <span className='step'>\n      <ReductionMessage lastReduction={ lastReduction } />\n      <div className='inlineblock' >\n        <p className='stepNumber' >\n          { step } :\n        </p>\n        { printer.print() }\n        { children }\n        {\n          stepRecord.message === '' ?\n            null\n            :\n            exerciseStep === false ?\n            <p className='stepMessage' >\n              { stepRecord.message }\n            </p>\n            :\n            incorrectStep === true ?\n              <p className='stepMessage incorrect' >\n                Incorrect input: <i className='userInput'>`{ stepRecord.message.substr(15) }`</i>\n              </p>\n            :\n              <p className='stepMessage correct' >\n                { stepRecord.message }\n              </p>\n        }\n      </div>\n    </span>\n  )\n}","import React, { useContext, ReactNode } from 'react'\n\nimport Step from './Step'\n// import { AddBoxContext } from './MethodInjector'\nimport { Breakpoint, StepRecord, UntypedLambdaState, EvaluationStrategy } from './Types'\nimport { MacroMap } from '@lambdulus/core'\n// import { DeleteBox, MakeActiveContext } from './BoxSpace'\n\ninterface InactiveExpressionProps {\n  className : string\n  breakpoints : Array<Breakpoint>\n  history : Array<StepRecord>\n  strategy : EvaluationStrategy\n  SDE : boolean\n  macrotable : MacroMap\n\n  createBoxFrom (stepRecord : StepRecord, macrotable : MacroMap) : UntypedLambdaState\n}\n\n\nexport default function InactiveExpression (props : InactiveExpressionProps) : JSX.Element {\n  const { className, SDE, macrotable } = props\n  // const deleteBox = useContext(DeleteBox)\n  // const makeActive = useContext(MakeActiveContext)\n\n  return (\n    <div\n      className={ className + ' inactiveBox' }\n    >\n      <ul className='UL'>\n        <li key={ 0 } className='activeStep LI'>\n          <Step\n            breakpoints={ props.breakpoints }\n            strategy={ props.strategy }\n            addBreakpoint={ () => {} } // blank function - NOOP\n            stepRecord={ props.history[0] }\n            lastStep={ false }\n            SDE={ SDE }\n            macrotable={ macrotable }\n          >\n            \n            {/* <AddBoxContext.Consumer>\n              {\n                (addBox : (boxState : BoxState) => void) => <i\n                  className=\"hiddenIcon far fa-clone\"\n                  onClick={ () => addBox(props.createBoxFrom(props.history[0])) }\n                />\n              }\n            </AddBoxContext.Consumer> */}\n            \n          </Step>\n        </li>\n      </ul>\n      <p className='inactiveMessage'>\n        Collapsing { props.history.length - 1 } { props.history.length === 2 ? 'step' : 'steps' }. Click to activate this box.\n      </p>\n    </div>\n  )\n}","import React, { ChangeEvent, KeyboardEvent } from 'react'\nimport MonacoEditor from 'react-monaco-editor'\n\nimport '../styles/Editor.css'\n\n// import { EvaluationStrategy } from '../App'\n\n\nexport enum ActionType {\n  ENTER_EXPRESSION = 'Enter Expression',\n  ENTER_EXERCISE = 'Enter Exercise',\n  NEXT_STEP = 'Next Step',\n  RUN = 'Run',\n  ENTER_MD = 'Enter MarkDown',\n}\n\ninterface EditorProperties {\n  placeholder: string\n  content : string\n  syntaxError : Error | null\n  submitOnEnter : boolean\n  shouldReplaceLambda : boolean\n  \n  onContent (content : string) : void\n  onShiftEnter () : void\n  onCtrlEnter () : void\n  onEnter () : void\n  onExecute () : void // TODO:delete\n  // onReset () : void\n}\n\nexport default function Editor (props : EditorProperties) : JSX.Element {\n  const {\n    placeholder,\n    content,\n    syntaxError,\n    submitOnEnter,\n    shouldReplaceLambda,\n\n    onContent,\n    onEnter,\n    onShiftEnter,\n    onCtrlEnter,\n    // onExecute,\n  } : EditorProperties = props\n  const lines : number = content.split('\\n').length\n\n  const onChange = (content : string) => {\n    // let { target : { value : content } } : { target : { value : string } } = event\n    // const caretPosition : number = event.target.selectionEnd\n\n    if (shouldReplaceLambda) {\n      content = content.replace(/\\\\/g, 'λ')\n    }\n\n    onContent(content)\n  }\n\n  // TODO: Editor should not decide that - it should only implement onEnter onShiftEnter onCtrlEnter\n  const onKeyDown = (event : KeyboardEvent<HTMLDivElement>) => {\n    if ( ! event.shiftKey && ! event.ctrlKey && event.key === 'Enter') {\n      \n      if (submitOnEnter) {\n        event.stopPropagation()\n        event.preventDefault()\n        onEnter()\n      }\n\n      return\n    }\n\n    if (event.shiftKey && event.key === 'Enter') {\n      event.preventDefault()\n      onShiftEnter()\n    }\n    if (event.ctrlKey && event.key === 'Enter') {\n      event.preventDefault()\n      onCtrlEnter()\n    }\n\n    // TODO: not yet\n    // if (event.ctrlKey && event.key === 'r') {\n    //   event.preventDefault()\n    //   onReset()\n    // }\n  }\n\n  return (\n    <div className='editorContainer'>\n      {\n        syntaxError ?\n        <p className='editorError'>\n          { `${syntaxError}` }\n        </p>\n        :\n        null\n      }\n\n      <div className=\"editor\">\n        <InputField\n          placeholder={ placeholder }\n          content={ content }\n          onContent={ (content : string) => onChange(content) }\n          onKeyDown={ onKeyDown }\n        />\n      </div>\n    </div>\n  )\n}\n\ninterface InputProps {\n  placeholder : string\n  content : string\n  // onChange (event : ChangeEvent<HTMLTextAreaElement>) : void\n  onContent (content : string) : void\n  onKeyDown (event : KeyboardEvent<HTMLDivElement>) : void\n}\n\nfunction InputField (props : InputProps) : JSX.Element {\n  const { placeholder, content, onKeyDown, onContent } : InputProps = props\n  const lines : number = content.split('\\n').length\n\n\n  return (\n    <div\n      onKeyDownCapture={ onKeyDown }\n    >\n      <MonacoEditor\n        // width=\"800\"\n        height={ Math.max(5 * 19 ,Math.min(40 * 19, (lines + 1) * 19)) } // 10 lines by default\n        language=\"markdown\"\n        theme=\"vs-light\"\n        value={ content }\n        options={ {\n          formatOnPaste : true,\n          minimap : { enabled : false },\n          renderLineHighlight : \"none\",\n          scrollBeyondLastLine : false,\n          overviewRulerBorder : false,\n          scrollbar : {\n            // handleMouseWheel : false,\n          } } }\n        onChange={ (content : string) => onContent(content) }\n        // editorDidMount={ ::this.editorDidMount }\n        editorDidMount={ (editor, monaco) => editor.focus() }\n      />\n    </div>\n  )\n}","import React, { PureComponent } from 'react'\n\nimport '../styles/DebugControls.css'\n\n\ninterface Props {\n  isRunning : boolean\n  // disableRun : boolean /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n\n  onStep : () => void\n  onRun : () => void\n}\n\n// TODO: Consider separating the `keydown` event handler into different file\n// it would be singleton module, which would make sure ONLY ONE `DebugControls` component\n// is subscribed to the `keydown` event\nexport default class DebugControls extends PureComponent<Props> {\n  constructor (props : Props) {\n    super(props)\n  }\n\n  componentDidMount () : void {\n    document.onkeydown = (event) => {\n      console.log('KEYDOWN', event.key)\n      if ( ( ! event.shiftKey)\n        && ( ! event.ctrlKey)\n        && ( ! event.altKey)\n        && ( ! event.metaKey)\n        && (event.key === 'F8' || event.key === 'F9')) {\n          if (event.key === 'F8') {\n            event.preventDefault()\n            this.props.onStep()\n          }\n          if (event.key === 'F9') { /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n            event.preventDefault()\n            this.props.onRun()\n          }\n        }\n    }\n  }\n\n  componentWillUnmount () : void {\n    document.onkeydown = () => void 0\n  }\n\n  render () {\n    const { isRunning, onStep, onRun } : Props = this.props\n  \n    const runMessage : string =\n      isRunning ? 'Stop the Evaluation (Press F9)' :  'Evaluate the Expression (Press F9)'\n\n    return (\n      <div className='debug-controls'>\n        {\n          /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n          // this.props.disableRun ?\n            // null\n          // :\n          <button\n            title={ runMessage }\n            type=\"button\"\n            className='btn debug-controls--run'\n            onClick={ onRun }\n          >\n            <span className='debug-controls--btn-label'>{ isRunning ? 'Stop' : 'Run' }</span>\n            <i className=\"mini-icon fas fa-play\"></i>\n          </button>\n        }\n        \n        \n        <button\n          title='Evaluate Next Step (Press F8)'\n          type=\"button\"\n          className='btn debug-controls--step'\n          onClick={ onStep }\n          disabled={ isRunning }\n        >\n          <span className='debug-controls--btn-label'>Step</span>\n          <i className=\"mini-icon fas fa-step-forward\"></i>\n        </button>\n      </div>\n    )\n  }\n\n}"," import React, { PureComponent, ReactNode, ChangeEvent } from 'react'\n\n// import Controls from './Controls' // TODO: Controls are gonna be imported from the Frontend app - or maybe not even imported just passed as children\nimport Step from './Step'\nimport { UntypedLambdaState, Breakpoint, StepRecord, UntypedLambdaExpressionState, EvaluationStrategy } from './Types'\nimport Editor from '../components/Editor'\n// import { DeleteBox } from './BoxSpace'\n// import { AddBoxContext } from './MethodInjector'\nimport { mapLeftFromTo } from '../misc'\nimport DebugControls from '../components/DebugControls'\n// import BoxTopBar from './BoxTopBar'\n// import Controls from './ExerciseSwitch'\n\nimport './styles/Expression.css'\nimport { MacroMap } from '@lambdulus/core'\n\n\ninterface EvaluatorProps {\n  className : string\n  state : UntypedLambdaExpressionState\n  breakpoints : Array<Breakpoint>\n  history : Array<StepRecord>\n  editor : {\n    placeholder : string\n    content : string\n    caretPosition : number\n    syntaxError : Error | null\n  }\n  isNormalForm : boolean\n  isExercise : boolean\n\n  createBoxFrom (stepRecord : StepRecord) : UntypedLambdaState\n  setBoxState (state : UntypedLambdaExpressionState) : void\n  onContent (content : string) : void\n  onEnter () : void\n  onExecute () : void\n  addBox (box : UntypedLambdaState) : void\n  shouldShowDebugControls : boolean\n}\n\nexport default class Expression extends PureComponent<EvaluatorProps> {\n  constructor (props : EvaluatorProps) {\n    super(props)\n\n    this.addBreakpoint = this.addBreakpoint.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { className, state, editor, shouldShowDebugControls, isExercise, setBoxState } = this.props\n\n    const { isRunning, strategy, SDE, macrotable, SLI } : UntypedLambdaExpressionState = state\n\n    const {\n      placeholder,\n      content,\n      caretPosition,\n      syntaxError,\n    } = editor\n\n    const uniq : string = Date.now().toString()\n\n\n    return (\n      <div className={ className }>\n        <ul className='UL'>\n          {\n            mapLeftFromTo(0, this.props.history.length - 2, this.props.history, (stepRecord : StepRecord, i : Number) =>\n              <li key={ i.toString() } className='inactiveStep LI' >\n                <Step\n                  breakpoints={ this.props.breakpoints }\n                  strategy={ this.props.state.strategy }\n                  addBreakpoint={ () => {} }\n                  stepRecord={ stepRecord }\n                  lastStep={ false }\n                  SDE={ SDE }\n                  macrotable={ macrotable }\n                >\n                  {/* <i\n                    className=\"hiddenIcon far fa-clone\"\n                    title='Clone this expression to the new box'\n                    onClick={ (e : any) => {\n                      e.stopPropagation()\n                      this.props.addBox(this.props.createBoxFrom(stepRecord))\n                    } }\n                  /> */}\n                </Step>\n              </li>)\n          }\n          <li key={this.props.history.length - 1} className='activeStep LI'>\n            <Step\n              breakpoints={ this.props.breakpoints }\n              strategy={ this.props.state.strategy }\n              addBreakpoint={ this.addBreakpoint }\n              stepRecord={ this.props.history[this.props.history.length - 1] }\n              lastStep={ true }\n              SDE={ SDE }\n              macrotable={ macrotable }\n            >\n                {/* <i\n                  className=\"hiddenIcon far fa-clone\"\n                  title='Clone this expression to the new box'\n                  onClick={ (e : any) => {\n                    e.stopPropagation() // TODO: maybe I shouldn't do this\n                    // maybe instead I should drop the `focusedBoxIndex` and stop caring if Box has been clicked\n                    // instead I could always render whole and complete Box if user does not collapsed it\n                    // I need to think this through\n                    this.props.addBox(this.props.createBoxFrom(this.props.history[this.props.history.length - 1]))\n                   } }\n                /> */}\n            </Step>\n          </li>\n        </ul>\n        {\n          (isExercise && ! this.props.isNormalForm) ?\n            <div>\n\n              <Editor\n                placeholder={ placeholder } // data\n                content={ content } // data\n                syntaxError={ syntaxError } // data\n                submitOnEnter={ true } // data\n\n                onContent={ this.props.onContent } // fn\n                onEnter={ this.props.onEnter } // fn // tohle asi bude potreba\n                onShiftEnter={ () => void 0 }\n                onCtrlEnter={ () => void 0 }\n                onExecute={ this.props.onExecute } // fn // tohle asi bude potreba\n                shouldReplaceLambda={ true }\n              />\n\n\n              <div className='untyped-lambda--pick-strategy untyped-lambda-settings-strategies inlineblock'>\n                <p className='stratsLabel inlineblock'>Strategy:</p>\n                \n                {/* <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                  <input\n                    id={ `untyped-lambda-settings--simplified-strategy-${uniq}` }\n                    type='radio'\n                    name={ `untyped-lambda-settings--strategy-${uniq}` }\n                    // style=\"fill\"\n                    checked={\n                      strategy === EvaluationStrategy.ABSTRACTION\n                    }\n                    \n                    onChange={\n                      () => setBoxState({ ...state, strategy : EvaluationStrategy.ABSTRACTION })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--simplified-strategy-${uniq}` }>\n                    Simplified\n                  </label>\n                </span> */}\n\n                <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                  <input\n                    id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n                    type='radio'\n                    name={ `untyped-lambda-settings--strategy-${uniq}` }\n                    // style=\"fill\"\n                    checked={\n                      strategy === EvaluationStrategy.NORMAL\n                    }\n\n                    onChange={\n                      () => setBoxState({ ...state, strategy : EvaluationStrategy.NORMAL })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n                    Normal\n                  </label>\n                </span>\n\n                <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                  <input\n                    id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n                    type='radio'\n                    name={ `untyped-lambda-settings--strategy-${uniq}` }\n                    // style=\"fill\"\n                    checked={\n                      strategy === EvaluationStrategy.APPLICATIVE\n                    }\n                    \n                    onChange={\n                      () => setBoxState({ ...state, strategy : EvaluationStrategy.APPLICATIVE })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n                    Applicative\n                  </label>\n                </span>\n              </div>\n            </div>\n          :\n            ( ! this.props.isNormalForm && shouldShowDebugControls) ?\n              <div style={ { height: '2.5em' } }>\n                <span className='untyped-lambda--debug-ctrl'>\n                  <DebugControls\n                    isRunning={ isRunning }\n                    onStep={ this.props.onEnter }\n                    onRun={ this.props.onExecute }\n                    // disableRun={ SDE }\n                  />\n                </span>\n                \n                <div className='untyped-lambda--pick-strategy untyped-lambda-settings-strategies inlineblock'>\n                  <p className='stratsLabel inlineblock'>Strategy:</p>\n                  \n                  {/* <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                    <input\n                      id={ `untyped-lambda-settings--simplified-strategy-${uniq}` }\n                      type='radio'\n                      name={ `untyped-lambda-settings--strategy-${uniq}` }\n                      // style=\"fill\"\n                      checked={\n                        strategy === EvaluationStrategy.ABSTRACTION\n                      }\n                      \n                      onChange={\n                        () => setBoxState({ ...state, strategy : EvaluationStrategy.ABSTRACTION })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--simplified-strategy-${uniq}` }>\n                      Simplified\n                    </label>\n                  </span> */}\n\n                  <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                    <input\n                      id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n                      type='radio'\n                      name={ `untyped-lambda-settings--strategy-${uniq}` }\n                      // style=\"fill\"\n                      checked={\n                        strategy === EvaluationStrategy.NORMAL\n                      }\n\n                      onChange={\n                        () => setBoxState({ ...state, strategy : EvaluationStrategy.NORMAL })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n                      Normal\n                    </label>\n                  </span>\n\n                  <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n                    <input\n                      id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n                      type='radio'\n                      name={ `untyped-lambda-settings--strategy-${uniq}` }\n                      // style=\"fill\"\n                      checked={\n                        strategy === EvaluationStrategy.APPLICATIVE\n                      }\n                      \n                      onChange={\n                        () => setBoxState({ ...state, strategy : EvaluationStrategy.APPLICATIVE })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n                      Applicative\n                    </label>\n                  </span>\n                </div>\n\n                {/* Here add SDE switch/checkbox */}\n                {\n                  <span\n                    className='untyped-lambda-settings-SDE-'\n                    title='Simplified Evaluation'>\n                    <input\n                      id={ `untyped-lambda-settings--SDE-${uniq}` }\n                      type='checkbox'\n                      checked={ SDE }\n                      disabled={ false }\n                      // shape=\"fill\"\n                      \n                      onChange={\n                        (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                          setBoxState({ ...state, SDE : e.target.checked })\n                      }\n                    />\n                    <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n                      Simplified Evaluation\n                    </label>\n                  </span>\n                }\n\n                <span\n                  className='untyped-lambda-settings-SLI-'\n                  title='Single Letters as Names without Spaces'>\n                  <input\n                    id={ `untyped-lambda-settings--SLI-${uniq}` }\n                    type='checkbox'\n                    checked={ SLI }\n                    disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n                    // shape=\"fill\"\n                    \n                    onChange={\n                      (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                        setBoxState({ ...state, SLI : e.target.checked })\n                    }\n                  />\n                  <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n                    Single Letter Names\n                  </label>\n                </span>\n\n              </div>\n            :\n              null\n        }\n      </div>\n    )\n  }\n\n  addBreakpoint (breakpoint : Breakpoint) : void {\n    let { state, setBoxState, breakpoints } = this.props\n  \n    // const index : number = breakpoints.findIndex((brk : Breakpoint) => {\n    //   return brk.type === breakpoint.type && brk.context.identifier === breakpoint.context.identifier\n    // })\n    // \n    // if (index >= 0) {\n    //   breakpoints.splice(index, 1)\n    // }\n    // else {\n    //   breakpoints.push(breakpoint)\n    // }\n    // \n    // setBoxState({\n    //   ...state,\n    //   breakpoints,\n    // })\n\n    const brkpts : Array<Breakpoint> = breakpoints.filter((brk : Breakpoint) => {\n      return brk.type !== breakpoint.type || brk.context.identifier !== breakpoint.context.identifier\n    })\n\n    if (brkpts.length !== breakpoints.length) {\n      setBoxState({\n        ...state,\n        breakpoints : brkpts,\n      })\n    }\n    else {\n      setBoxState({\n        ...state,\n        breakpoints : [ ...breakpoints, breakpoint ]\n      })\n    }    \n  }\n}","import React, { PureComponent, ReactNode } from 'react'\n\nimport {\n  AST,\n  ASTReduction,\n  None,\n  NormalEvaluator,\n  Beta,\n  Lambda,\n  Variable,\n  Expansion,\n  ChurchNumeral,\n  Macro,\n  Token,\n  tokenize,\n  parse,\n  ApplicativeEvaluator,\n  OptimizeEvaluator,\n  MacroMap,\n  NormalAbstractionEvaluator,\n  Application,\n  ASTReductionType,\n  Eta,\n  Alpha,\n} from \"@lambdulus/core\"\n\nimport './styles/EvaluatorBox.css'\n\nimport { BoxType, BoxState } from '../Types'\n\nimport { TreeComparator } from './TreeComparator'\nimport EmptyExpression from './EmptyExpression'\nimport InactiveEvaluator from './InactiveExpression'\nimport Expression from './Expression'\nimport { EvaluationStrategy, PromptPlaceholder, UntypedLambdaState, Evaluator, StepRecord, Breakpoint, UntypedLambdaType, UntypedLambdaExpressionState } from './Types'\nimport { reportEvent } from '../misc'\nimport { start } from 'repl'\nimport { findSimplifiedReduction, MacroBeta, tryMacroContraction, strategyToEvaluator } from './AppTypes'\n// import { MContext } from './MacroContext'\n\n\nexport interface EvaluationProperties {\n  state : UntypedLambdaExpressionState\n  isActive : boolean\n  isFocused : boolean\n  macroContext : { macrotable : MacroMap }\n\n  setBoxState (state : UntypedLambdaExpressionState) : void\n  addBox (box : UntypedLambdaState) : void\n}\n\nexport default class ExpressionBox extends PureComponent<EvaluationProperties> {\n  constructor (props : EvaluationProperties) {\n    super(props)\n\n    this.onContent = this.onContent.bind(this)\n    this.onSimplifiedStep = this.onSimplifiedStep.bind(this)\n    this.onStep = this.onStep.bind(this)\n    this.onExecute = this.onExecute.bind(this)\n    this.onRun = this.onRun.bind(this)\n    this.onStop = this.onStop.bind(this)\n    this.shouldBreak = this.shouldBreak.bind(this)\n    this.createBoxFrom = this.createBoxFrom.bind(this)\n    this.onSimplifiedRun = this.onSimplifiedRun.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { state, isActive, addBox } : EvaluationProperties = this.props\n    const {\n      minimized,\n      history,\n      breakpoints,\n      strategy,\n      expression,\n      editor,\n      SDE,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n\n    let className : string = 'box boxEval'\n    const { isNormalForm } = history.length ? history[history.length - 1] : { isNormalForm : false }\n\n    // TODO: Maybe I will take this out\n    // Frontend may take care of that\n    if (minimized) {\n      return (\n        <InactiveEvaluator\n          className={ className }\n          breakpoints={ breakpoints }\n          history={ history }\n          strategy={ this.props.state.strategy }\n          SDE={ SDE }\n          macrotable={ macrotable }\n          \n          createBoxFrom={ this.createBoxFrom }\n        />\n      )\n    }\n\n    return (\n      <Expression\n        className={ className }\n        isExercise={ false }\n        state={ state }\n        breakpoints={ breakpoints }\n        history={ history }\n        editor={ editor }\n        isNormalForm={ isNormalForm }\n        shouldShowDebugControls={ isActive }\n\n        createBoxFrom={ this.createBoxFrom }\n        setBoxState={ this.props.setBoxState }\n        onContent={ this.onContent }\n        onEnter={ this.onStep }\n        onExecute={ this.onExecute }\n        addBox={ addBox }\n      />\n    )\n  }\n\n  createBoxFrom (stepRecord : StepRecord) : UntypedLambdaState {\n    const { state } : EvaluationProperties = this.props\n    const {\n      strategy,\n      SLI,\n      SDE,\n      expandStandalones,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n    const { ast } = stepRecord\n    const content = ast.toString()\n\n    return {\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype : UntypedLambdaType.EMPTY,\n      title : `Copy of ${state.title}`,\n      minimized : false,\n      menuOpen : false,\n      settingsOpen : false,\n      expression : \"\",\n      ast : null,\n      history : [],\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 10,\n      strategy,\n      SDE,\n      SLI,\n      expandStandalones,\n      macrolistOpen : false,\n      macrotable : { }, // ...macrotable, ...this.props.macroContext.macrotable\n      editor : {\n        placeholder : PromptPlaceholder.EVAL_MODE,\n        content : Object.entries(macrotable).map(([name, definition] : [string, string]) => name + ' := ' + definition + ' ;\\n' ).join('') + content,\n        caretPosition : content.length,\n        syntaxError : null,\n      }\n    }\n  }\n\n  onContent (content : string) : void {\n    const { state, setBoxState } = this.props\n\n    setBoxState({\n      ...state,\n      editor : {\n        ...state.editor,\n        content,\n        syntaxError : null,\n      }\n    })\n  }\n\n  onSimplifiedStep () : void {\n    // console.log(\"DOIN ONE STEP       _______     SIMPLIFIED\")\n\n    const { state, setBoxState } = this.props\n    const { strategy, history, editor : { content }, macrotable } = state\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    const { lastReduction } = stepRecord\n    const ast = stepRecord.ast.clone()\n    let newast = ast\n\n    if (isNormalForm) {\n      return\n    }\n\n    // console.log('looooooooooooooooooooooooooooking')\n\n    //                                                    fix this part please\n    const [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(ast, strategy, macrotable)\n    // console.log('BACK TO THE WORLD HERE')\n    \n    let message = ''\n    let isNowNormalForm = false\n\n    // console.log(nextReduction)\n\n    if (nextReduction instanceof MacroBeta) {\n      // console.log(\"YES MACRO BETA HERE\")\n      // z macrobeta si vytahnu aritu makra\n      const arity : number = nextReduction.arity\n\n      // a zkontroluju jestli velikost pole odpovida arite\n      if (nextReduction.applications.length !== arity) {\n        // pokud arita nesedi - je vetsi nez delka pole aplikaci -->\n        // --> musim vyhlasit warning a rict, ze tenhle krok neni uplne gooda\n        // console.log(\"ARITY IS WRONG - probably too few arguments\")\n        stepRecord.message = `Macro ${tryMacroContraction(nextReduction.applications[0].left, macrotable)} is given too few arguments.`\n\n        newast = evaluateReduction(newast)\n\n        // this.setState({\n        //   ...state,\n        // })\n        // return\n      }\n      else {\n        // this is what happens when ::single-step\n        //\n        newast = evaluateReduction(newast)\n        // debugger\n\n        // if we are not ::single-step --> findSimplifiedReduction won't return MacroBeta -- instead\n        // it will return the first redex --> first beta reduction in the list and then it's not macro reduction problem anymore\n        // so next consecutive redex search will just find pretty normal situation as it probably should\n      }\n    }\n    else if (nextReduction instanceof None) {\n      stepRecord.isNormalForm = true\n      stepRecord.message = 'Expression is in normal form.'\n      setBoxState({\n        ...state,\n      })\n      return\n    }\n    else {\n      newast = evaluateReduction(newast)\n    }\n\n\n    {\n      // console.log('copak se tohle vubec neprovadi????????????????')\n      const astCopy : AST = newast.clone()\n      const [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(astCopy, strategy, macrotable)\n      // const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (nextReduction instanceof None) {\n        isNowNormalForm = true\n        message = 'Expression is in normal form.'\n        \n        reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n      }\n    }\n\n    setBoxState({\n      ...state,\n      history : [ ...history, { ast : newast, lastReduction : nextReduction, step : step + 1, message, isNormalForm : isNowNormalForm } ],\n    })\n\n    reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n    return\n    \n    {\n      // None\n      // console.log(\"_________________________________ NONE\")\n      // stepRecord.isNormalForm = true\n      // stepRecord.message = 'Expression is in normal form.'\n      \n      // setBoxState({\n      //   ...state,\n      // })\n      \n      // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n      // return\n    }\n    {\n      // Expansion -> then None\n      // stepRecord.lastReduction = newreduction\n      // stepRecord.isNormalForm = true\n      // stepRecord.message = 'Expression is in normal form.'\n      \n      // setBoxState({\n      //   ...state,\n      // })\n      \n      // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n      // return\n    }\n    {\n      // Expandion -> then Any ASTReduction inside the expanded Macro --> need to Expand first\n      // ast = newAst\n\n      // let message = ''\n      // let isNormal = false\n\n      // setBoxState({\n      //   ...state,\n      //   history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ]\n      // })\n      // return\n    }\n    {\n      // Expansion -> then Any ASTReduction completely outside of Macro --> skip the Expansion and do the next thing instead\n      // ast = newevaluator.perform()\n      // const p = parent as AST\n      // const ts = treeSide as String\n      // (p as any)[ts as any] = M\n      // // parent should be not-null\n      // // because if there was a Macro which we were able to Expand\n      // // and then there has been found Redex which is not part of the newly expanded sub-tree\n      // // the new Redex simply has to be in different part of the tree --> which means - M (original Macro) is not the root\n\n      // let message = ''\n      // let isNormal = false\n\n      // setBoxState({\n      //   ...state,\n      //   history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ]\n      // })\n      // return\n    }\n  }\n\n  onStep () : void {\n    // console.log('DOIN ONE STEP')\n    const { state, setBoxState } = this.props\n    const { strategy, SDE, history, editor : { content } } = state\n\n    // this is gonna change - Simplified Evaluation won't be strategy - but Strategy Modifier\n    if (SDE) {\n      this.onSimplifiedStep()\n      return\n    }\n\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { ast, lastReduction } = stepRecord\n    ast = ast.clone()\n\n  \n    if (isNormalForm) {\n      return\n    }\n\n    const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = evaluator.nextReduction\n  \n    if (evaluator.nextReduction instanceof None) {\n      stepRecord.isNormalForm = true\n      stepRecord.message = 'Expression is in normal form.'\n      \n      setBoxState({\n        ...state,\n      })\n      \n      reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n      return\n    }\n  \n    ast = evaluator.perform()\n\n    let message = ''\n    let isNormal = false\n\n    {\n      const astCopy : AST = ast.clone()\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (evaluator.nextReduction instanceof None) {\n        isNormal = true\n        message = 'Expression is in normal form.'\n        \n        reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n      }\n    }\n\n    // ANCHOR: #0023\n    // NOTE: This is completely crazy - it doesn't make any sense\n    // TODO: Investigate more - and fix the functionality\n    // it probably should check if the current AST Root is a Macro and next Reduction is Expansion of exactly this AST\n    // then it can say - it is in the Normal Form - if some settings enables it - not by default though\n    //\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   console.log('CURRENT IS MACRO OR NUMBER')\n\n    //   stepRecord.isNormalForm = true\n    //   stepRecord.message = 'Expression is in normal form.'\n\n    //   reportEvent('Evaluation Step', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n  \n    setBoxState({\n      ...state,\n      history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ],\n\n    })\n\n    reportEvent('Evaluation Step', 'Step', ast.toString())\n  }\n\n  onExecute () : void {\n    const { state, setBoxState } = this.props\n    const { isRunning, SDE } = state\n\n    if (isRunning) {\n      this.onStop()\n    }\n    else {\n      const { timeout, history } = state\n      const stepRecord = history[history.length - 1]\n  \n      if (stepRecord.isNormalForm) {\n        return\n      }\n      \n      const { ast, step, lastReduction, isNormalForm, message } = stepRecord\n      history.push(history[history.length - 1])\n      history[history.length - 2] = { ast : ast.clone(), step, lastReduction, message : 'Skipping some steps...', isNormalForm }\n\n      if (SDE) {\n        setBoxState({\n          ...state,\n          isRunning : true,\n          timeoutID : window.setTimeout(this.onSimplifiedRun, timeout),\n        })\n      }\n      else {\n        setBoxState({\n          ...state,\n          isRunning : true,\n          timeoutID : window.setTimeout(this.onRun, timeout),\n        })\n      }\n\n      \n\n      reportEvent('Execution', 'Run Evaluation', ast.toString())\n    }\n  }\n\n  onSimplifiedRun () : void {\n    const { state, setBoxState } = this.props\n    const { strategy, macrotable } = state\n    let { history, isRunning, breakpoints, timeoutID, timeout } = state\n    const stepRecord : StepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { lastReduction } = stepRecord\n\n    if ( ! isRunning) {\n      return\n    }\n\n    if (isNormalForm) {\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n\n    let { ast } = stepRecord\n    const newast : AST = ast.clone()\n    const [nextReduction, evaluateReduction] : [ASTReduction, (ast : AST) => AST] = findSimplifiedReduction(newast, strategy, macrotable)\n\n/////////////////////////////////////////////////////////////////////////////////////////\n    // const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = nextReduction\n    \n    if (nextReduction instanceof None) {\n      // TODO: consider immutability\n      history.pop()\n      history.push({\n        ast,\n        lastReduction : stepRecord.lastReduction,\n        step,\n        message : 'Expression is in normal form.',\n        isNormalForm : true\n      })\n  \n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n\n    const arityBreakpoint : Breakpoint | undefined = breakpoints.find((brk : Breakpoint) => brk.type === ASTReductionType.GAMA && ! brk.broken.has((nextReduction as MacroBeta).applications[0]))\n    if (nextReduction instanceof MacroBeta && nextReduction.arity !== nextReduction.applications.length && arityBreakpoint === undefined) {\n      stepRecord.message = `Macro ${tryMacroContraction(nextReduction.applications[0].left, macrotable)} is given too few arguments.`\n    \n      // completely same code as in breakpoint section -- TODO: refactor and unify pls\n      window.clearTimeout(timeoutID)\n      reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n      breakpoints.push({ type : ASTReductionType.GAMA, context : nextReduction.applications[0], broken : new Set([ nextReduction.applications[0] ]) })\n\n      setBoxState({\n        ...state,\n        breakpoints,\n        isRunning : false,\n        timeoutID,\n      })\n\n      return\n    }\n  \n    // TODO: maybe refactor a little\n    const breakpoint : Breakpoint | undefined = breakpoints.find(\n      (breakpoint : Breakpoint) =>\n        this.shouldBreak(breakpoint, nextReduction)\n    )\n\n    if (breakpoint !== undefined) {\n      // TODO: consider immutability\n      if (nextReduction instanceof Expansion) {\n        breakpoint.broken.add(nextReduction.target)\n      }\n      if (nextReduction instanceof Beta && nextReduction.redex.left instanceof Lambda) {\n        breakpoint.broken.add(nextReduction.redex.left.argument)\n      }\n\n      window.clearTimeout(timeoutID)\n      reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID,\n      })\n\n      return\n    }\n  \n    ast = evaluateReduction(newast)\n\n    history[history.length - 1] = { ast, lastReduction, step : step + 1, message : '', isNormalForm }\n\n    // NOTE: Same thing as #0023\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   history[history.length - 1] = { ast, lastReduction, step : step + 1, message : 'Expression is in normal form.', isNormalForm : true }\n\n    //   reportEvent('Evaluation Run Ended', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n    \n    setBoxState({\n      ...state,\n      timeoutID : window.setTimeout(this.onSimplifiedRun, timeout)\n    })\n  }\n\n  onRun () : void {\n    const { state, setBoxState } = this.props\n    const { strategy } = state\n    let { history, isRunning, breakpoints, timeoutID, timeout } = state\n    const stepRecord : StepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { lastReduction } = stepRecord\n\n    if ( ! isRunning) {\n      return\n    }\n    \n    if (isNormalForm) {\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n  \n    let { ast } = stepRecord\n    const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = normal.nextReduction\n    \n    if (normal.nextReduction instanceof None) {\n      // TODO: consider immutability\n      history.pop()\n      history.push({\n        ast,\n        lastReduction : stepRecord.lastReduction,\n        step,\n        message : 'Expression is in normal form.',\n        isNormalForm : true\n      })\n  \n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID : undefined,\n      })\n  \n      return\n    }\n  \n    // TODO: maybe refactor a little\n    const breakpoint : Breakpoint | undefined = breakpoints.find(\n      (breakpoint : Breakpoint) =>\n        this.shouldBreak(breakpoint, normal.nextReduction)\n    )\n\n    if (breakpoint !== undefined) {\n      // TODO: consider immutability\n      if (normal.nextReduction instanceof Expansion) {\n        breakpoint.broken.add(normal.nextReduction.target)\n      }\n      if (normal.nextReduction instanceof Beta && normal.nextReduction.redex.left instanceof Lambda) {\n        breakpoint.broken.add(normal.nextReduction.redex.left.argument)\n      }\n\n      window.clearTimeout(timeoutID)\n      reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n\n      setBoxState({\n        ...state,\n        isRunning : false,\n        timeoutID,\n      })\n\n      return\n    }\n  \n    ast = normal.perform()\n\n    history[history.length - 1] = { ast, lastReduction, step : step + 1, message : '', isNormalForm }\n\n    // NOTE: Same thing as #0023\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   history[history.length - 1] = { ast, lastReduction, step : step + 1, message : 'Expression is in normal form.', isNormalForm : true }\n\n    //   reportEvent('Evaluation Run Ended', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n    \n    setBoxState({\n      ...state,\n      timeoutID : window.setTimeout(this.onRun, timeout)\n    })\n  }\n\n  onStop () : void {\n    const { state, setBoxState } = this.props\n    const { timeoutID } = state\n  \n    window.clearTimeout(timeoutID)\n  \n    setBoxState({\n      ...state,\n      isRunning : false,\n      timeoutID : undefined\n    })\n  }\n\n  // TODO: breakpointy se pak jeste musi predelat\n  // TODO: don't forget on GAMA refactor\n  shouldBreak (breakpoint : Breakpoint, reduction : ASTReduction) : boolean {\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Beta && breakpoint.context instanceof Lambda\n    //     && reduction.target.identifier === breakpoint.context.body.identifier\n    //   ) {\n    //     return true\n    // }\n    if (reduction.type === breakpoint.type\n        && reduction instanceof Beta && breakpoint.context instanceof Variable\n        && reduction.redex.left instanceof Lambda\n        && reduction.redex.left.argument.identifier === breakpoint.context.identifier\n        && ! breakpoint.broken.has(reduction.redex.left.argument)\n    ) {\n      return true\n    }\n\n    if (reduction.type === breakpoint.type\n        && reduction instanceof Expansion && breakpoint.context instanceof ChurchNumeral\n        && reduction.target.identifier === breakpoint.context.identifier\n        && ! breakpoint.broken.has(reduction.target)\n    ) {\n      return true\n    }\n    if (reduction.type === breakpoint.type\n        && reduction instanceof Expansion && breakpoint.context instanceof Macro\n        && reduction.target.identifier === breakpoint.context.identifier\n        && ! breakpoint.broken.has(reduction.target)\n    ) {\n      return true\n    }\n  \n    return false\n  }\n\n}","import React from 'react'\nimport { MacroMap, builtinMacros } from '@lambdulus/core'\n\nimport './styles/MacroList.css'\n\n\nexport interface MacroProperties {\n  macroTable : MacroMap\n}\n\nexport default function MacroList (props : MacroProperties) : JSX.Element {\n  const { macroTable } = props\n\n  return (\n    <div className='macroSpace'>\n      <div className='builtinMacros'>\n        <p>Built-in Macros:</p>\n        <ul className='UL'>\n          { Object.entries(builtinMacros).map(([macroName, macroExpression]) =>\n            <div key={ macroName }>\n              <li className='LI dense-LI'>\n                <div className='macro-definition'>\n                  { macroName } := { macroExpression }\n                </div>\n              </li>\n            </div>\n          ) }\n        </ul>\n      </div>\n\n      <div className='userMacros'>      \n        <p>User-defined Macros:</p>\n        <ul className='UL'>\n          { Object.entries(macroTable).map(([macroName, macroExpression]) =>\n              <div key={ macroName }>\n                <li className='LI dense-LI'>\n                  <div className='macro-definition'>\n                    { macroName } := { macroExpression }\n                  </div>\n                </li>\n              </div>\n            ) }\n        </ul>\n      </div>\n    </div>\n  )\n}","import React, { PureComponent, ReactNode } from 'react'\n\nimport {\n  AST,\n  ASTReduction,\n  None,\n  NormalEvaluator,\n  Beta,\n  Lambda,\n  Variable,\n  Expansion,\n  ChurchNumeral,\n  Macro,\n  Token,\n  tokenize,\n  parse,\n  ApplicativeEvaluator,\n  OptimizeEvaluator,\n  MacroMap,\n  NormalAbstractionEvaluator,\n} from \"@lambdulus/core\"\n\nimport './styles/EvaluatorBox.css'\n\nimport { BoxType, BoxState } from '../Types'\n\nimport { TreeComparator } from './TreeComparator'\nimport EmptyEvaluator from './EmptyExpression'\nimport InactiveEvaluator from './InactiveExpression'\nimport Expression from './Expression'\nimport { EvaluationStrategy, PromptPlaceholder, UntypedLambdaState, Evaluator, StepRecord, Breakpoint, UntypedLambdaType, UntypedLambdaExpressionState } from './Types'\nimport { reportEvent } from '../misc'\nimport { strategyToEvaluator } from './AppTypes'\n// import { MContext } from './MacroContext'\n\n\nexport interface EvaluationProperties {\n  state : UntypedLambdaExpressionState\n  isActive : boolean\n  isFocused : boolean\n  macroContext : { macrotable : MacroMap }\n\n  setBoxState (state : UntypedLambdaExpressionState) : void\n  addBox (box : UntypedLambdaState) : void\n}\n\nexport default class ExerciseBox extends PureComponent<EvaluationProperties> {\n  constructor (props : EvaluationProperties) {\n    super(props)\n\n    this.onContent = this.onContent.bind(this)\n    this.onSubmitExpression = this.onSubmitExpression.bind(this)\n    this.parseExpression = this.parseExpression.bind(this)\n    this.onEnter = this.onEnter.bind(this)\n    this.onExerciseStep = this.onExerciseStep.bind(this)\n    this.onStep = this.onStep.bind(this)\n    this.onExecute = this.onExecute.bind(this)\n    this.onRun = this.onRun.bind(this)\n    this.onStop = this.onStop.bind(this)\n    this.shouldBreak = this.shouldBreak.bind(this)\n    this.createBoxFrom = this.createBoxFrom.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { state, isActive, addBox } : EvaluationProperties = this.props\n    const {\n      minimized,\n      history,\n      breakpoints,\n      strategy,\n      expression,\n      editor,\n      SDE,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n\n    let className : string = 'box boxEval boxExercise'\n    const { isNormalForm } = history.length ? history[history.length - 1] : { isNormalForm : false }\n\n    // TODO: Maybe I will take this out\n    // Frontend may take care of that\n    if (minimized) {\n      return (\n        <InactiveEvaluator\n          className={ className }\n          breakpoints={ breakpoints }\n          history={ history }\n          strategy={ this.props.state.strategy }\n          SDE={ SDE }\n          macrotable={ macrotable }\n          \n          createBoxFrom={ this.createBoxFrom }\n        />\n      )\n    }\n\n    return (\n      <Expression\n        className={ className }\n        isExercise={ true }\n        state={ state }\n        breakpoints={ breakpoints }\n        history={ history }\n        editor={ editor }\n        isNormalForm={ isNormalForm }\n        shouldShowDebugControls={ isActive }\n\n        createBoxFrom={ this.createBoxFrom }\n        setBoxState={ this.props.setBoxState }\n        onContent={ this.onContent }\n        onEnter={ this.onEnter }\n        onExecute={ this.onExecute }\n        addBox={ addBox }\n      />\n    )\n  }\n\n  createBoxFrom (stepRecord : StepRecord) : UntypedLambdaState {\n    const { state } : EvaluationProperties = this.props\n    const {\n      strategy,\n      SLI,\n      SDE,\n      expandStandalones,\n      macrotable,\n    } : UntypedLambdaExpressionState = state\n    const { ast } = stepRecord\n    const content = ast.toString()\n\n    return {\n      __key : Date.now().toString(),\n      type : BoxType.UNTYPED_LAMBDA,\n      subtype : UntypedLambdaType.EMPTY,\n      title : `Copy of ${state.title}`,\n      minimized : false,\n      menuOpen : false,\n      settingsOpen : false,\n      expression : \"\",\n      ast : null,\n      history : [],\n      isRunning : false,\n      breakpoints : [],\n      timeoutID : undefined,\n      timeout : 10,\n      strategy,\n      SDE,\n      SLI,\n      expandStandalones,\n      macrolistOpen : false,\n      macrotable : { }, // ...macrotable, ...this.props.macroContext.macrotable\n      editor : {\n        placeholder : PromptPlaceholder.EVAL_MODE,\n        content : Object.entries(macrotable).map(([name, definition] : [string, string]) => name + ' := ' + definition + ' ;\\n').join('') + content,\n        caretPosition : content.length,\n        syntaxError : null,\n      }\n    }\n  }\n\n  onContent (content : string) : void {\n    const { state, setBoxState } = this.props\n\n    setBoxState({\n      ...state,\n      editor : {\n        ...state.editor,\n        content,\n        syntaxError : null,\n      }\n    })\n  }\n\n  onEnter () : void {\n    const { expression, editor : { content } } = this.props.state\n\n    if (content === '') {\n      this.onStep()\n    }\n\n    this.onExerciseStep()\n  }\n\n  onSubmitExpression () : void {\n    const { state, setBoxState } = this.props\n    const {\n      strategy,\n      editor : { content },\n    } = state\n\n    try {\n      const ast : AST = this.parseExpression(content)\n\n      let message = ''\n      let isNormal = false\n\n      const astCopy : AST = ast.clone()\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (evaluator.nextReduction instanceof None) {\n        isNormal = true\n        message = 'Expression is in normal form.'\n        \n        // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n      }\n\n      setBoxState({\n        ...state,\n        ast,\n        expression : content,\n        history : [ {\n          ast : ast.clone(),\n          lastReduction : new None,\n          step : 0,\n          message,\n          isNormalForm : isNormal\n        } ],\n        editor : {\n          content : '',\n          caretPosition : 0,\n          placeholder : PromptPlaceholder.EVAL_MODE,\n          syntaxError : null,\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit valid', content)\n    } catch (exception) {\n      setBoxState({\n        ...state,\n        editor : {\n          ...state.editor,\n          syntaxError : exception.toString(),\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit invalid', content)\n    }\n  }\n\n  onExerciseStep () {\n    // console.log('EXERCISE STEP')\n    const { state, setBoxState } = this.props\n    const { strategy, history, editor : { content } } = state\n    \n    try {\n      const userAst : AST = this.parseExpression(content)\n      const stepRecord : StepRecord = history[history.length - 1]\n      const { isNormalForm, step } = stepRecord\n      let { ast, lastReduction } = stepRecord\n      ast = ast.clone()\n\n      if (isNormalForm) {\n        // TODO: do something about it\n        // say user - there are no more steps and it is in normal form        \n        // TODO: consider immutability\n        stepRecord.message = 'No more steps available. Expression is in normal form.'\n\n        setBoxState({\n          ...state,\n        })\n\n        reportEvent('Exercise Step', 'Step Already in normal form', content)\n\n        return\n      }\n    \n      const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n      lastReduction = normal.nextReduction\n    \n      if (normal.nextReduction instanceof None) {\n        // TODO: refactor PLS - update history\n        // TODO: say user it is in normal form and they are mistaken\n        stepRecord.isNormalForm = true\n        stepRecord.message = 'Expression is already in normal form.'\n        \n        setBoxState({\n          ...state,\n        })\n\n        reportEvent('Exercise Step', 'Step Already in Normal Form', content)\n        \n        return\n      }\n    \n      ast = normal.perform()\n\n      let isNormal = false\n\n      {\n        const astCopy : AST = ast.clone()\n        const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n        \n        if (evaluator.nextReduction instanceof None) {\n          isNormal = true\n          \n          reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n        }\n      }\n    \n      let message : string = ''\n      const comparator : TreeComparator = new TreeComparator([ userAst, ast ])\n\n      if (comparator.equals) {\n        ast = userAst\n        message = 'Correct.'\n\n        reportEvent('Exercise Step', 'Valid Step', content)\n      }\n      else {\n        // TODO: say user it was incorrect\n        // TODO: na to se pouzije uvnitr EvaluatorState prop messages nebo tak neco\n        // console.log('Incorrect step')\n        message = `Incorrect step. ${content}`\n\n        reportEvent('Exercise Step', 'Invalid Step', content)\n      }\n\n      setBoxState({\n        ...state,\n        history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ],\n        editor : {\n          ...state.editor,\n          content : '',\n          caretPosition : 0,\n          placeholder : PromptPlaceholder.VALIDATE_MODE,\n          syntaxError : null,\n        }\n      })\n    } catch (exception) {\n      // TODO: print syntax error\n      // TODO: do it localy - no missuse of onSubmit\n\n      // TODO: print syntax error\n\n      reportEvent('Exercise Step', 'Syntax error in Step', content)\n    }\n  }\n\n  onStep () : void {\n    // console.log('DOIN ONE STEP')\n    const { state, setBoxState } = this.props\n    const { strategy, history, editor : { content } } = state\n    const stepRecord = history[history.length - 1]\n    const { isNormalForm, step } = stepRecord\n    let { ast, lastReduction } = stepRecord\n    ast = ast.clone()\n  \n    if (isNormalForm) {\n      return\n    }\n\n    const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    lastReduction = normal.nextReduction\n  \n    if (normal.nextReduction instanceof None) {\n      // console.log('NEXT IS NONE')\n      stepRecord.isNormalForm = true\n      stepRecord.message = 'Expression is in normal form.'\n      \n      setBoxState({\n        ...state,\n      })\n      \n      reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())\n\n      return\n    }\n  \n    ast = normal.perform()\n\n    let message = 'Evaluating One Step for You'\n    let isNormal = false\n\n    {\n      const astCopy : AST = ast.clone()\n      const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n      \n      if (evaluator.nextReduction instanceof None) {\n        isNormal = true\n        message = 'Expression is in normal form.'\n        \n        reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n      }\n    }\n\n    // ANCHOR: #0023\n    // NOTE: This is completely crazy - it doesn't make any sense\n    // TODO: Investigate more - and fix the functionality\n    // it probably should check if the current AST Root is a Macro and next Reduction is Expansion of exactly this AST\n    // then it can say - it is in the Normal Form - if some settings enables it - not by default though\n    //\n    // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    //   console.log('CURRENT IS MACRO OR NUMBER')\n\n    //   stepRecord.isNormalForm = true\n    //   stepRecord.message = 'Expression is in normal form.'\n\n    //   reportEvent('Evaluation Step', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // }\n  \n    setBoxState({\n      ...state,\n      history : [ ...history, { ast, lastReduction, step : step + 1, message, isNormalForm : isNormal } ],\n\n    })\n\n    reportEvent('Exercise Empty Evaluation Step', 'Step', ast.toString())\n  }\n\n  onExecute () : void {\n    // const { state, setBoxState } = this.props\n    // const { isRunning } = state\n\n    // // if (isExercise) {\n    // //   // TODO: exercises can not be run - some message to user???\n    // //   return\n    // // }\n\n    // if (isRunning) {\n    //   this.onStop()\n    // }\n    // else {\n    //   const { timeout, history } = state\n    //   const stepRecord = history[history.length - 1]\n  \n    //   if (stepRecord.isNormalForm) {\n    //     return\n    //   }\n      \n    //   const { ast, step, lastReduction, isNormalForm, message } = stepRecord\n    //   history.push(history[history.length - 1])\n    //   history[history.length - 2] = { ast : ast.clone(), step, lastReduction, message : 'Skipping some steps...', isNormalForm }\n\n    //   setBoxState({\n    //     ...state,\n    //     isRunning : true,\n    //     timeoutID : window.setTimeout(this.onRun, timeout),\n    //   })\n\n    //   reportEvent('Execution', 'Run Evaluation', ast.toString())\n    // }\n  }\n\n  onRun () : void {\n    // const { state, setBoxState } = this.props\n    // const { strategy } = state\n    // let { history, isRunning, breakpoints, timeoutID, timeout } = state\n    // const stepRecord : StepRecord = history[history.length - 1]\n    // const { isNormalForm, step } = stepRecord\n    // let { lastReduction } = stepRecord\n\n    // if ( ! isRunning) {\n    //   return\n    // }\n    \n    // if (isNormalForm) {\n    //   setBoxState({\n    //     ...state,\n    //     isRunning : false,\n    //     timeoutID : undefined,\n    //   })\n  \n    //   return\n    // }\n  \n    // let { ast } = stepRecord\n    // const normal : Evaluator = new (strategyToEvaluator(strategy) as any)(ast)\n    // lastReduction = normal.nextReduction\n    \n    // if (normal.nextReduction instanceof None) {\n    //   // TODO: consider immutability\n    //   history.pop()\n    //   history.push({\n    //     ast,\n    //     lastReduction : stepRecord.lastReduction,\n    //     step,\n    //     message : 'Expression is in normal form.',\n    //     isNormalForm : true\n    //   })\n  \n    //   setBoxState({\n    //     ...state,\n    //     isRunning : false,\n    //     timeoutID : undefined,\n    //   })\n  \n    //   return\n    // }\n  \n    // // TODO: maybe refactor a little\n    // const breakpoint : Breakpoint | undefined = breakpoints.find(\n    //   (breakpoint : Breakpoint) =>\n    //     this.shouldBreak(breakpoint, normal.nextReduction)\n    // )\n\n    // if (breakpoint !== undefined) {\n    //   // TODO: consider immutability\n    //   if (normal.nextReduction instanceof Expansion) {\n    //     breakpoint.broken.add(normal.nextReduction.target)\n    //   }\n    //   if (normal.nextReduction instanceof Beta && normal.nextReduction.redex.left instanceof Lambda) {\n    //     breakpoint.broken.add(normal.nextReduction.redex.left.argument)\n    //   }\n\n    //   window.clearTimeout(timeoutID)\n    //   reportEvent('Evaluation Run Ended', 'Breakpoint was reached', ast.toString())\n\n\n    //   setBoxState({\n    //     ...state,\n    //     isRunning : false,\n    //     timeoutID,\n    //   })\n\n    //   return\n    // }\n  \n    // ast = normal.perform()\n\n    // history[history.length - 1] = { ast, lastReduction, step : step + 1, message : '', isNormalForm }\n\n    // // NOTE: Same thing as #0023\n    // // if (ast instanceof Macro || ast instanceof ChurchNumeral) {\n    // //   history[history.length - 1] = { ast, lastReduction, step : step + 1, message : 'Expression is in normal form.', isNormalForm : true }\n\n    // //   reportEvent('Evaluation Run Ended', 'Step Normal Form Reached with Number or Macro', ast.toString())\n    // // }\n    \n    // setBoxState({\n    //   ...state,\n    //   timeoutID : window.setTimeout(this.onRun, timeout)\n    // })\n  }\n\n  onStop () : void {\n    // const { state, setBoxState } = this.props\n    // const { timeoutID } = state\n  \n    // window.clearTimeout(timeoutID)\n  \n    // setBoxState({\n    //   ...state,\n    //   isRunning : false,\n    //   timeoutID : undefined\n    // })\n  }\n\n  // TODO: breakpointy se pak jeste musi predelat\n  shouldBreak (breakpoint : Breakpoint, reduction : ASTReduction) : boolean {\n    // // if (reduction.type === breakpoint.type\n    // //     && reduction instanceof Beta && breakpoint.context instanceof Lambda\n    // //     && reduction.target.identifier === breakpoint.context.body.identifier\n    // //   ) {\n    // //     return true\n    // // }\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Beta && breakpoint.context instanceof Variable\n    //     && reduction.redex.left instanceof Lambda\n    //     && reduction.redex.left.argument.identifier === breakpoint.context.identifier\n    //     && ! breakpoint.broken.has(reduction.redex.left.argument)\n    // ) {\n    //   return true\n    // }\n\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Expansion && breakpoint.context instanceof ChurchNumeral\n    //     && reduction.target.identifier === breakpoint.context.identifier\n    //     && ! breakpoint.broken.has(reduction.target)\n    // ) {\n    //   return true\n    // }\n    // if (reduction.type === breakpoint.type\n    //     && reduction instanceof Expansion && breakpoint.context instanceof Macro\n    //     && reduction.target.identifier === breakpoint.context.identifier\n    //     && ! breakpoint.broken.has(reduction.target)\n    // ) {\n    //   return true\n    // }\n  \n    return false\n  }\n\n  // THROWS Exceptions\n  parseExpression (expression : string) : AST {\n    // const { macroTable } = this.props\n\n    const { SLI : singleLetterVars } = this.props.state\n\n    const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars })\n    const ast : AST = parse(tokens, this.props.macroContext.macrotable) // macroTable\n\n    return ast\n  }\n}","import React, { ChangeEvent } from 'react'\nimport { UntypedLambdaSettings, EvaluationStrategy, SettingsEnabled } from './Types'\n\nimport './styles/Settings.css'\n\n// const { Switch, Radio } = require('pretty-checkbox-react')\n\n\ninterface Props {\n  settings : UntypedLambdaSettings\n  settingsEnabled : SettingsEnabled\n\n  change : (settings : UntypedLambdaSettings) => void\n}\n\nexport default function Settings (props : Props) : JSX.Element {\n  const { settings, change, settingsEnabled } : Props = props\n  const { SLI, expandStandalones, strategy, SDE } : UntypedLambdaSettings = settings\n  const { SLI : SLI_E, expandStandalones : expSt_E, strategy : strat_E } : SettingsEnabled = settingsEnabled\n\n  const uniq : string = Date.now().toString()\n\n  return (\n    <div className='untyped-lambda-box--settings'>\n      {/* <h3>Untyped Lambda Calculus</h3> */}\n\n      {\n        SLI_E ?\n          <span\n            className='untyped-lambda-settings-SLI'\n            title='Single Letters as Names without Spaces'>\n            <input\n              id={ `untyped-lambda-settings--SLI-${uniq}` }\n              type='checkbox'\n              checked={ SLI }\n              disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n              // shape=\"fill\"\n              \n              onChange={\n                (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                  change({ ...settings, SLI : e.target.checked })\n              }\n            />\n            <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n              Single Letter Names\n            </label>\n          </span>\n        :\n          null\n      }\n\n      {\n        <span\n          className='untyped-lambda-settings-SDE'\n          title='Simplified Evaluation'>\n          <input\n            id={ `untyped-lambda-settings--SDE-${uniq}` }\n            type='checkbox'\n            checked={ SDE }\n            disabled={ false }\n            // shape=\"fill\"\n            \n            onChange={\n              (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                change({ ...settings, SDE : e.target.checked })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n            Simplified Evaluation\n          </label>\n        </span>\n      }\n\n      {\n        expSt_E && false ? // hiding this out - I am not sure what this should be in the first place\n          <span\n            className='untyped-lambda-settings-expand'\n            title='Expand Numbers and Macros at the End'>\n            <input\n              id={ `untyped-lambda-settings--expand-${uniq}` }\n              type='checkbox'\n              checked={ expandStandalones }\n              disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n              // shape=\"fill\"\n              \n              onChange={\n                (e : ChangeEvent<HTMLInputElement>) => {\n                  // tady nejakej destructuring\n                  change({ ...settings, expandStandalones : e.target.checked })\n                }\n              }\n            />\n            <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--expand-${uniq}` }>\n              Expand Macros and Numbers at the End\n            </label>\n          </span>\n        :\n          null\n      }\n\n      {\n        strat_E ?\n          <div className='untyped-lambda-settings-strategies inlineblock'>\n            <p className='stratsLabel inlineblock'>Evaluation Strategies:</p>\n            {/* <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n              <input\n                id={ `untyped-lambda-settings--simplified-strategy-${uniq}` }\n                type='radio'\n                name={ `untyped-lambda-settings--strategy-${uniq}` }\n                // style=\"fill\"\n                checked={\n                  strategy === EvaluationStrategy.ABSTRACTION\n                }\n                \n                onChange={\n                  () => change({ ...settings, strategy : EvaluationStrategy.ABSTRACTION })\n                }\n              />\n              <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--simplified-strategy-${uniq}` }>\n                Simplified\n              </label>\n            </span> */}\n\n            <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n              <input\n                id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n                type='radio'\n                name={ `untyped-lambda-settings--strategy-${uniq}` }\n                // style=\"fill\"\n                checked={\n                  strategy === EvaluationStrategy.NORMAL\n                }\n\n                onChange={\n                  () => change({ ...settings, strategy : EvaluationStrategy.NORMAL })\n                }\n              />\n              <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n                Normal\n              </label>\n            </span>\n\n            <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n              <input\n                id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n                type='radio'\n                name={ `untyped-lambda-settings--strategy-${uniq}` }\n                // style=\"fill\"\n                checked={\n                  strategy === EvaluationStrategy.APPLICATIVE\n                }\n                \n                onChange={\n                  () => change({ ...settings, strategy : EvaluationStrategy.APPLICATIVE })\n                }\n              />\n              <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n                Applicative\n              </label>\n            </span>\n          </div>\n        :\n          null\n    }\n    </div>\n  )\n}","import React, { useContext, ReactNode, ChangeEvent } from 'react'\n\nimport Editor from '../components/Editor'\n// import { MakeActiveContext, DeleteBox } from './BoxSpace'\nimport { StepRecord, UntypedLambdaExpressionState, EvaluationStrategy } from './Types'\n\nimport './styles/EmptyExpression.css'\n\ninterface EmptyExpressionProps {\n  className : string\n  isActive : boolean\n  isMinimized : boolean\n  state : UntypedLambdaExpressionState\n  editor : {\n    placeholder : string\n    content : string\n    caretPosition : number\n    syntaxError : Error | null\n  }\n  // history : Array<StepRecord>\n\n  onContent (content : string) : void\n  onDebug () : void\n  onExercise () : void\n  setBoxState (box : UntypedLambdaExpressionState) : void\n}\n\n\nexport default function EmptyExpression(props : EmptyExpressionProps) : JSX.Element{\n  const { className, isActive, editor, isMinimized, setBoxState, state } = props\n  const {\n    placeholder,\n    content,\n    caretPosition,\n    syntaxError,\n  } = editor\n  const { SDE, strategy, SLI } = state\n\n  const uniq : string = Date.now().toString()\n\n  // const makeActive = useContext(MakeActiveContext)\n  // const deleteBox = useContext(DeleteBox)\n\n  return (\n    <div\n      className={ `${className} ${isActive ? '' : ' inactiveBox'}` }\n    >\n      {\n        ! isMinimized ?\n          (\n            <div>\n              <Editor\n                placeholder={ placeholder } // data\n                content={ content } // data\n                syntaxError={ syntaxError } // data\n                submitOnEnter={ false } // data\n                shouldReplaceLambda={ true }\n\n                onContent={ props.onContent } // fn\n                onEnter={ () => void 0 } // fn\n                onCtrlEnter={ props.onDebug }\n                onShiftEnter={ SDE ? () => void 0 : props.onExercise /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */ }\n                onExecute={ () => void 0 } // fn\n              />\n\n              <div className='debug-controls'>\n                <button\n                  title='Debug this Expression in the Evaluator (Ctrl + Enter)'\n                  type=\"button\"\n                  className='open-as-debug btn'\n                  onClick={ props.onDebug }\n                >\n                  <span\n                    className='untyped-lambda--submit-expression--btn-label'\n                  >\n                    Debug\n                  </span>\n                </button>\n                \n                {\n                  SDE ? /* TODO: this is just for now -- because I am not sure students will know how to exercise with simplified */\n                    null\n                  :\n                  <button\n                    title='Exercise this Expression Yourself (Shift + Enter)'\n                    type=\"button\"\n                    className='open-as-exercise btn'\n                    onClick={ props.onExercise }\n                  >\n                    <span className='untyped-lambda--submit-expression--btn-label'>Exercise</span>\n                  </button>\n                }\n                \n              </div>\n            </div>\n          )\n          :\n          (\n            <div>\n              <p className='inactiveMessage'>\n                Collapsing Empty Expression Box. Click to activate this box.\n              </p>\n            </div>\n          )\n      }\n\n\n      <div\n        className='untyped-lambda--pick-strategy untyped-lambda-settings-strategies inlineblock'\n        style={ { height: '2.5em' } }\n      >\n        <p className='stratsLabel inlineblock'>Strategy:</p>\n        <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n          <input\n            id={ `untyped-lambda-settings--normal-strategy-${uniq}` }\n            type='radio'\n            name={ `untyped-lambda-settings--strategy-${uniq}` }\n            // style=\"fill\"\n            checked={\n              strategy === EvaluationStrategy.NORMAL\n            }\n\n            onChange={\n              () => setBoxState({ ...state, strategy : EvaluationStrategy.NORMAL })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--normal-strategy-${uniq}` }>\n            Normal\n          </label>\n        </span>\n\n        <span className='untyped-lambda-settings--strategy-radio-wrapper'>\n          <input\n            id={ `untyped-lambda-settings--applicative-strategy-${uniq}` }\n            type='radio'\n            name={ `untyped-lambda-settings--strategy-${uniq}` }\n            // style=\"fill\"\n            checked={\n              strategy === EvaluationStrategy.APPLICATIVE\n            }\n            \n            onChange={\n              () => setBoxState({ ...state, strategy : EvaluationStrategy.APPLICATIVE })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--applicative-strategy-${uniq}` }>\n            Applicative\n          </label>\n        </span>\n      </div>\n\n      {/* Here add SDE switch/checkbox */}\n      {\n        <span\n          className='untyped-lambda-settings-SDE-'\n          title='Simplified Evaluation'>\n          <input\n            id={ `untyped-lambda-settings--SDE-${uniq}` }\n            type='checkbox'\n            checked={ SDE }\n            disabled={ false }\n            // shape=\"fill\"\n            \n            onChange={\n              (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n                setBoxState({ ...state, SDE : e.target.checked })\n            }\n          />\n          <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SDE-${uniq}` }>\n            Simplified Evaluation\n          </label>\n        </span>\n      }\n\n      <span\n        className='untyped-lambda-settings-SLI-'\n        title='Single Letters as Names without Spaces'>\n        <input\n          id={ `untyped-lambda-settings--SLI-${uniq}` }\n          type='checkbox'\n          checked={ SLI }\n          disabled={ false } // TODO: tohle bude rozhodne chtit prepsat\n          // shape=\"fill\"\n          \n          onChange={\n            (e : ChangeEvent<HTMLInputElement>) => // tady nejakej destructuring\n              setBoxState({ ...state, SLI : e.target.checked })\n          }\n        />\n        <label className='untyped-lambda-settings-label' htmlFor={ `untyped-lambda-settings--SLI-${uniq}` }>\n          Single Letter Names\n        </label>\n      </span>\n\n\n  </div>\n  )\n}","import React, { PureComponent } from 'react'\n\nimport { BoxState, BoxType } from '../Types'\nimport { UntypedLambdaState, UntypedLambdaType, UntypedLambdaExpressionState, UntypedLambdaSettings, PromptPlaceholder, EvaluationStrategy } from './Types'\nimport ExpressionBox from './ExpressionBox'\n// import Macro from './Macro'\nimport MacroList from './MacroList'\nimport { UNTYPED_LAMBDA_INTEGRATION_STATE, GLOBAL_SETTINGS_ENABLER, strategyToEvaluator, findSimplifiedReduction, toMacroMap } from './AppTypes'\nimport ExerciseBox from './ExerciseBox'\nimport Settings from './Settings'\nimport EmptyExpression from './EmptyExpression'\nimport { reportEvent } from '../misc'\nimport { None, Evaluator, Token, tokenize, parse, AST, NormalEvaluator, ApplicativeEvaluator, OptimizeEvaluator, NormalAbstractionEvaluator, MacroMap, ASTReduction } from '@lambdulus/core'\n\n// import macroctx from './MacroContext'\n\n\ninterface Props {\n  state : UntypedLambdaState\n  isActive : boolean\n  isFocused : boolean\n\n  setBoxState (state : UntypedLambdaState) : void\n  addBox (box : UntypedLambdaState) : void\n}\n\nexport default class UntypedLambdaBox extends PureComponent<Props> {\n  constructor (props : Props) {\n    super(props)\n  }\n\n  render () {\n    const { state, isActive, isFocused, setBoxState, addBox } : Props = this.props\n    const { settingsOpen, subtype, macrolistOpen, SLI, expandStandalones, strategy, SDE, editor, minimized } : UntypedLambdaState = state\n\n\n    const renderBoxContent = () => {\n      switch (subtype) {\n        case UntypedLambdaType.EMPTY:\n          return (\n            <EmptyExpression\n              className='box boxEval'\n              isActive={ isActive }\n              isMinimized={ minimized }\n              editor={ editor }\n              state={ state }\n              onContent={(content : string) =>\n                setBoxState({\n                  ...state,\n                  editor : {\n                    ...state.editor,\n                    content,\n                    syntaxError : null,\n                  }\n                })\n              }\n              onDebug={ () => this.onSubmitExpression(UntypedLambdaType.ORDINARY) }\n              onExercise={ () => this.onSubmitExpression(UntypedLambdaType.EXERCISE) }\n              setBoxState={ setBoxState }\n            />\n          )\n  \n        case UntypedLambdaType.ORDINARY:\n          return (\n            <ExpressionBox\n              state={ state }\n              isActive={ isActive }\n              isFocused={ isFocused }\n              macroContext={ UNTYPED_LAMBDA_INTEGRATION_STATE }\n              setBoxState={ setBoxState }\n              addBox={ addBox }\n            />\n          )\n        \n        case UntypedLambdaType.EXERCISE:\n          return (\n            <ExerciseBox\n              state={ state }\n              isActive={ isActive }\n              isFocused={ isFocused }\n              macroContext={ UNTYPED_LAMBDA_INTEGRATION_STATE }\n              setBoxState={ setBoxState }\n              addBox={ addBox }\n            />\n          )\n      }\n    }\n\n    return (\n      <div\n        ref={ (elem : any) => {\n          // This is just temporary\n          // should be replaced with much finer logic\n          // like: store ref to the state and then scroll to the part of the Box which should be visible\n          // depending on the action user just did\n          // for now - it will do\n          if (elem !== null && isActive) {\n            const boundingRect = elem.getBoundingClientRect()\n            const viewportHeight : number = window.innerHeight\n            if (boundingRect.bottom > viewportHeight) {\n              elem.scrollIntoView(false)\n            }\n          }\n        } }\n      >\n        {\n          settingsOpen ?\n            <div className='box-settings'>\n              Box Local Settings:\n              <Settings\n                settings={ { type : BoxType.UNTYPED_LAMBDA, SLI, expandStandalones, strategy, SDE } }\n                settingsEnabled={ GLOBAL_SETTINGS_ENABLER }\n\n                change={ (settings : UntypedLambdaSettings) => {\n                  setBoxState({\n                    ...state,\n                    ...settings\n                  })\n                } }\n              />\n            </div>\n          :\n            null\n        }\n        {\n          macrolistOpen ?\n            <div className='untyped-lambda-box--macrolist'>\n              <MacroList macroTable={ state.macrotable }  />\n              {/* // TODO: this will just get this? */}\n            </div>\n          :\n            null\n        }\n\n        { renderBoxContent() }\n\n      </div>\n    )\n  }\n\n  onSubmitExpression (subtype : UntypedLambdaType) : void {\n    const { state, setBoxState } = this.props\n    const {\n      editor : { content },\n      strategy,\n      SDE,\n    } = state\n\n    const definitions : Array<string> = content.split(';')\n    const expression : string = definitions.pop() || \"\"\n    const macromap : MacroMap = toMacroMap(definitions)\n    \n    try {\n      const ast : AST = this.parseExpression(expression, macromap)\n\n      let message = ''\n      let isNormal = false\n\n      const astCopy : AST = ast.clone()\n\n      const nextReduction = (() => {\n        if (SDE) {\n          return findSimplifiedReduction(astCopy, strategy, macromap)[0]\n        }\n        else {\n          const evaluator : Evaluator = new (strategyToEvaluator(strategy) as any)(astCopy)\n          return evaluator.nextReduction\n        }\n      })()\n\n      \n      if (nextReduction instanceof None) {\n        isNormal = true\n        message = 'Expression is in normal form.'\n        \n        // reportEvent('Evaluation Step', 'Step Normal Form Reached', ast.toString())  \n      }\n\n      setBoxState({\n        ...state,\n        ast,\n        subtype,\n        expression : content,\n        macrotable : macromap,\n        history : [ {\n          ast : ast.clone(),\n          lastReduction : new None,\n          step : 0,\n          message,\n          isNormalForm : isNormal\n        } ],\n        editor : {\n          content : content,\n          caretPosition : 0,\n          placeholder : PromptPlaceholder.EVAL_MODE,\n          syntaxError : null,\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit valid', content)\n    } catch (exception) {\n      setBoxState({\n        ...state,\n        editor : {\n          ...state.editor,\n          syntaxError : exception.toString(),\n        }\n      })\n\n      reportEvent('Submit Expression', 'submit invalid', content)\n    }\n  }\n\n  // THROWS Exceptions\n  parseExpression (expression : string, macrotable : MacroMap) : AST {\n    // const { macroTable } = this.props\n\n    const { SLI : singleLetterVars } = this.props.state\n\n    const tokens : Array<Token> = tokenize(expression, { lambdaLetters : ['λ'], singleLetterVars })\n    const ast : AST = parse(tokens, macrotable) // macroTable\n\n    return ast\n  }\n\n}","import React from 'react'\n\nimport 'github-markdown-css'\nimport { NoteState } from './AppTypes'\nimport Editor from '../components/Editor'\n\nimport './styles/Note.css'\n\nconst ReactMarkdown = require('react-markdown')\n\nexport interface NoteProperties {\n  state : NoteState\n  isActive : boolean\n  isFocused : boolean\n\n  setBoxState (state : NoteState) : void\n}\n\nexport default function Note (props : NoteProperties) : JSX.Element {\n  const {\n    state : {\n      note,\n      editor : { placeholder, content, caretPosition, syntaxError },\n      isEditing,\n    },\n    isActive,\n    isFocused,\n    setBoxState,\n  } = props\n  \n  const onContent = (content : string) => {\n    setBoxState({\n      ...props.state,\n      note : content,\n      editor : {\n        ...props.state.editor,\n        content,\n        syntaxError : null,\n      }\n    })\n    // this.updateURL(expression) // tohle musim nejak vyresit - mozna ta metoda setBoxState v APP bude checkovat propisovat do URL\n  }\n\n    if (isEditing) { // TODO: isFocused removed just for now\n    return (\n      <div className='box boxNoteEditor'>\n        <Editor\n          placeholder={ placeholder } // data\n          content={ content } // data\n          syntaxError={ syntaxError } // data\n          submitOnEnter={ false } // data\n          shouldReplaceLambda={ false }\n          \n          onContent={ onContent } // fn\n          onEnter={ () => void 0 } // fn\n          onCtrlEnter={ () => void 0 }\n          onShiftEnter={ () => void 0 }\n          onExecute={ () => {} } // fn\n          // onReset={ this.onClear } // fn not yet\n        />\n      </div>\n    )\n  }\n\n\n  return (\n    <div\n      className='box boxNote'\n      onClick={ () => \n        isActive &&\n        setBoxState({\n        ...props.state,\n        isEditing : true,\n      }) }\n    >\n      <ReactMarkdown className='markdown-body' source={ note } />\n    </div>\n  )\n}","import React from 'react'\n\nexport default function Empty (props : {}) : JSX.Element {\n  return (\n    <div>\n      Empty Box\n    </div>\n  )\n}","import React, { useContext, ReactNode } from 'react'\n\n// import Evaluator from './ExpressionBox'\n// import MacroDefinition from './MacroDefinition'\n// import Note from './Note'\n// import { MacroTableContext } from './EvaluatorSpace'\n// import { SetBoxContext } from './BoxSpace'\nimport { BoxType, BoxState } from '../Types'\n\nimport { UntypedLambdaState } from '../untyped-lambda-integration/Types'\n\nimport UntypedLambdaBox from '../untyped-lambda-integration/UntypedLambdaBox'\n\nimport { NoteState } from '../markdown-integration/AppTypes'\nimport Note from '../markdown-integration/Note'\n\nimport Empty from '../empty-integration'\n\n// import { BoxState } from '../AppTypes'\n\ninterface BoxProperties {\n  state : BoxState\n  isActive : boolean\n  isFocused : boolean\n\n  updateBoxState (box : BoxState) : void\n  addBoxAfter (box : BoxState) : void\n}\n\nexport default function Box (props : BoxProperties) : JSX.Element {\n  const { state, isActive, isFocused, updateBoxState, addBoxAfter } : BoxProperties = props\n  const { type } = state\n\n  // const macroTable = useContext(MacroTableContext)\n  // const setBoxState = useContext(SetBoxContext)\n\n\n  if (type === BoxType.UNTYPED_LAMBDA) {\n    return (\n      <UntypedLambdaBox\n        state={ state as UntypedLambdaState }\n        isActive={ isActive }\n        isFocused={ isFocused }\n        // macroTable={ macroTable }\n        \n        setBoxState={ updateBoxState }\n        addBox={ addBoxAfter }\n      />\n    )\n  }\n  if (type === BoxType.MARKDOWN) {\n    return (\n      <Note\n        state={ state as NoteState }\n        isActive={ isActive }\n        isFocused={ isFocused }\n\n        setBoxState={ updateBoxState }\n      />\n    )\n  }\n  else {\n    return (\n      <Empty />\n    )\n  }\n\n  // if (type === BoxType.MACRO) {\n  //   return (\n  //     <div className=''>\n  //       <MacroDefinition\n  //         state={ state as MacroDefinitionState }\n  //         setBoxState={ setBoxState }\n\n  //         // addBox={ addBox }\n  //       />\n  //     </div>\n  //   )\n  // }\n\n  // if (type === BoxType.MARKDOWN) {\n  //   return (\n  //     <div className=''>\n  //       <Note\n  //         state={ state as NoteState }\n  //         isActive={ isActive }\n\n  //         // addBox={ addBox }\n  //       />\n  //     </div>\n  //   )\n  // }\n\n  // return null as any // never happens\n}","import React, { Component, MouseEvent } from 'react'\n\nimport Controls from './ExerciseSwitch'\nimport { UntypedLambdaState } from './Types'\nimport { BoxState } from '../Types'\n\nimport './styles/BoxTopBar.css'\n\n\ninterface Props {\n  state : UntypedLambdaState\n  isActive : boolean\n  removeBox : (e : MouseEvent) => void\n  updateBoxState : (box : BoxState) => void\n}\n\n\nexport default function BoxTopBar (props : Props) : JSX.Element {\n  const { state, isActive, removeBox, updateBoxState } = props\n  const { macrolistOpen } = state\n\n  return (\n    <div className=''>\n\n      <div\n        onClick={ (e) => {\n          e.stopPropagation()\n          updateBoxState({ ...state, macrolistOpen : ! macrolistOpen })\n        } }\n        className={ `untyped-lambda--top-bar-custom--button ${macrolistOpen ? 'menu-pressed-open' : ''}` }\n        title={ macrolistOpen ? 'Hide Macros' : 'Show All Macros for This Box' }\n      >\n        <i className=\"mini-icon fas fa-list-ul\" />\n      </div>\n\n      {/* {\n        expression === '' ?\n          null\n        :\n        <Controls\n          isExercise={ isExercise }\n          makeExercise={ () =>\n            updateBoxState({\n              ...state,\n              isExercise : true,\n              editor: {\n                ...state.editor,\n                placeholder : PromptPlaceholder.VALIDATE_MODE,\n              },\n            })\n          }\n          endExercise={ () =>\n            updateBoxState({\n              ...state,\n              isExercise : false,\n              editor: {\n                ...state.editor,\n                placeholder : PromptPlaceholder.EVAL_MODE,\n              },\n            })\n          }\n        />\n      } */}\n\n      {/* <i\n        className='removeBox far fa-trash-alt'\n        onClick={ removeBox }\n        title='Remove this Box'\n      /> */}\n\n      {/* {\n        state.minimized ?\n          <i\n            className=\"imizeBox fas fa-sort-down\"\n            onClick={ (e : MouseEvent) => {\n              e.stopPropagation()\n              updateBoxState({ ...state, minimized : false })\n            } }\n            title='Expand this Box'\n          />\n          :\n          <i\n            className=\"imizeBox fas fa-sort-up\"\n            onClick={ (e : MouseEvent) => {\n              e.stopPropagation()\n              updateBoxState({ ...state, minimized : true })\n            } }\n            title='Collapse this Box'\n          />\n      } */}\n    </div>\n  )\n}","import React, { Component, ChangeEvent, MouseEvent } from 'react'\n\nimport { NoteState, PromptPlaceholder } from './AppTypes'\n\nimport 'pretty-checkbox'\nimport './styles/EditingSwitch.css'\nimport { BoxState } from '../Types'\n\nconst { Switch } = require('pretty-checkbox-react')\n\n\ninterface Props {\n  state : NoteState\n  isActive : boolean\n  removeBox : (e : MouseEvent) => void\n  updateBoxState : (box : BoxState) => void\n}\n\n\nexport default function BoxTopBar (props : Props) : JSX.Element {\n  const { state, isActive, removeBox, updateBoxState } = props\n  const { note, isEditing, title } = state\n\n  return (\n    <div className=''>\n      {\n      // TODO: Remove This\n      /* <div className='topBarTitle' contentEditable={ true } onBlur={ (e) => updateBoxState({ ...state, title : e.target.textContent || \"\" }) }>\n        { title === \"\" ? \"Click Here to Change the Title\" : title }\n      </div> */}\n      <div className='markdown-controls' title='Edit as Markdown'>\n        \n        {/* This will be separated into it's own component */}\n        <div className='markdown-editing'>\n          <span\n            className={ `markdown-write ${isEditing ? 'markdown-selected' : ''}` }\n            onClick={ (e) => {\n              e.stopPropagation()\n              if (isEditing === false) {\n                updateBoxState({ ...state, isEditing : true})\n              }\n            } }\n          >\n            Edit\n          </span>\n          <span\n            className={ `markdown-preview ${isEditing ? '' : 'markdown-selected'}` }\n            onClick={ (e) => {\n              e.stopPropagation()\n              if (isEditing === true) {\n                updateBoxState({ ...state, isEditing : false})\n              }\n            } }\n          >\n            Preview\n          </span>\n        </div>\n      </div>\n\n      {/* <i\n        className='removeBox far fa-trash-alt'\n        onClick={ removeBox }\n        title='Remove this Box'\n      /> */}\n    </div>\n  )\n}","import React from 'react'\n\nexport default function EmptyTopBar (props : {}) : JSX.Element {\n  return (\n    <div></div>\n  )\n}","import React, { Component, MouseEvent } from 'react'\nimport { BoxType, BoxState, GlobalSettings, BoxesWhitelist } from '../Types'\nimport UntypedLambdaBTB from '../untyped-lambda-integration/BoxTopBar'\nimport { UntypedLambdaState } from '../untyped-lambda-integration/Types'\n\nimport MarkdownBTB from '../markdown-integration/BoxTopBar'\nimport { NoteState, resetMarkdownBox } from '../markdown-integration/AppTypes'\n\nimport EmptyBTB from '../empty-integration/BoxTopBar'\n\nimport '../styles/BoxTopBar.css'\nimport PickBoxTypeModal from './PickBoxTypeModal'\nimport { resetUntypedLambdaBox } from '../untyped-lambda-integration/AppTypes'\n\n\ntype BoxPlace = 'before' | 'after'\n\ninterface Props {\n  state : BoxState\n  isActive : boolean\n  isFocused : boolean\n  removeBox : (e : MouseEvent) => void\n  updateBoxState : (box : BoxState) => void\n  addBoxBefore : (box : BoxState) => void\n  addBoxAfter : (box : BoxState) => void\n  settings : GlobalSettings\n  whiteList : BoxesWhitelist\n}\n\ninterface State {\n  modalOpen : boolean\n  where : BoxPlace | null\n  menuOpen : boolean\n  shareLinkOpen : boolean\n}\n\n\nexport default class BoxTitleBar extends Component<Props, State> {\n\n  constructor (props : Props) {\n    super(props)\n\n    this.state = {\n      modalOpen : false,\n      where : null,\n      menuOpen : false,\n      shareLinkOpen : false,\n    }\n\n    this.selectBoxType = this.selectBoxType.bind(this)\n  }\n\n  render () : JSX.Element {\n    const { state, isActive, updateBoxState, removeBox, addBoxBefore, addBoxAfter } : Props = this.props\n    const { type, title, minimized, settingsOpen } = state\n\n    const { modalOpen, where, menuOpen, shareLinkOpen } : State = this.state\n\n    return (\n      <div className='boxTopBar'>\n        {/* {\n          modalOpen ?\n            <PickBoxTypeModal\n              addNew={ (box : BoxState) => {\n                if (where === 'before') {\n                  this.props.addBoxBefore(box)\n                }\n                else {\n                  this.props.addBoxAfter(box)\n                }\n                this.setState({ modalOpen : false, where : null, menuOpen : false })\n              } }\n              whiteList={ this.props.whiteList }\n              settings={ this.props.settings }\n            />\n          :\n            null\n        } */}\n\n\n        <div\n          className='topBarTitle'\n        >\n          {/* <span\n                className='box-top-bar--title-text'\n                contentEditable={ true }\n                onBlur={ (e) => updateBoxState({ ...state, title : e.target.textContent || \"\" })  }\n              >\n              { title }\n          </span> */}\n          {/* {\n            type !== BoxType.MARKDOWN ?\n              <span\n                className='box-top-bar--title-text'\n                contentEditable={ true }\n                onBlur={ (e) => updateBoxState({ ...state, title : e.target.textContent || \"\" })  }\n              >\n                { title }\n              </span>\n            :\n              null\n          } */}\n        </div>\n\n        {/* <div className='box-top-bar--menu-item--share-link'>\n          {\n            shareLinkOpen ?\n            \n            <span>{(() => {\n              const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n              searchParams.set('type', state.type)\n              searchParams.set('source', encodeURI((state as any).editor.content)) // todo: fix that `as any`\n              return window.location.host + '?' + searchParams.toString()})()}\n            </span>\n              :\n            null\n          }\n        </div> */}\n\n        <div className='box-top-bar-custom'>\n          {\n            (type === BoxType.UNTYPED_LAMBDA) ? \n              (\n                <UntypedLambdaBTB\n                  state={ state as UntypedLambdaState }\n                  isActive={ isActive }\n                  removeBox={ removeBox }\n                  updateBoxState={ updateBoxState }\n                />\n              )\n            :\n            (type === BoxType.MARKDOWN) ?\n              (\n                <MarkdownBTB\n                  state={ state as NoteState }\n                  isActive={ isActive }\n                  removeBox={ removeBox }\n                  updateBoxState={ updateBoxState }\n                />\n              )\n            :\n              (\n                <EmptyBTB />\n              )\n          }\n\n        </div>\n        <div className='box-top-bar-controls'>\n          {/* {\n            type !== BoxType.MARKDOWN ?\n            <div\n              onClick={ (e) => {\n                e.stopPropagation()\n                updateBoxState({ ...state, minimized : ! minimized })\n              } }\n              className='box-top-bar--controls--imize'\n              title={ minimized ? 'Expand this Box' : 'Collapse this Box' }\n            >\n              {\n                minimized ?\n                  <i className=\"mini-icon fas fa-caret-down\" />\n                :\n                  <i className=\"mini-icon fas fa-caret-up\" />\n              }\n            </div>\n            :\n              null\n          } */}\n\n          {/* <div\n            className='box-top-bar--controls--settings'\n            onClick={ (e) => {\n              e.stopPropagation()\n              updateBoxState({ ...state, settingsOpen : ! settingsOpen })\n            } }\n          >\n            <i className=\"mini-icon fas fa-cog\" />\n          </div> */}\n\n          <div\n            onClick={ (e) => {\n              e.stopPropagation()\n              this.setState({ menuOpen : ! menuOpen })\n            } }\n            className={ `box-top-bar--controls--menu ${menuOpen ? 'menu-pressed-open' : ''}` }\n          >\n            <i className=\"mini-icon fas fa-ellipsis-v\"></i>\n          </div>\n        </div>\n\n        {\n          menuOpen ?\n            <div\n              className='box-top-bar--menu'\n              ref={ (elem : any) => {\n                // just to be able to always see the menu\n                if (elem !== null) {\n                  const boundingRect = elem.getBoundingClientRect()\n                  const viewportHeight : number = window.innerHeight\n                  if (boundingRect.bottom > viewportHeight) {\n                    elem.scrollIntoView(false)\n                  }\n                }\n              } }\n            >\n              {/* TODO: move into ... Menu component */}\n              <div\n                className='box-top-bar--menu-item'\n                onClick={ () => {\n                  this.setState({ shareLinkOpen : true })\n                  const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n                  searchParams.set('type', state.type)\n                  searchParams.set('source', encodeURI((state as any).editor.content)) // todo: fix that `as any`\n\n                  if (state.type === BoxType.UNTYPED_LAMBDA) {\n                    searchParams.set('subtype', (state as UntypedLambdaState).subtype)\n                    searchParams.set('strategy', (state as UntypedLambdaState).strategy)\n                    searchParams.set('SDE', (state as UntypedLambdaState).SDE.toString())\n                    searchParams.set('SLI', (state as UntypedLambdaState).SLI.toString())\n                  }\n\n                  const url : string = window.location.host + '/holo' + '?' + searchParams.toString()\n\n                  navigator.clipboard.writeText(url)\n\n                  setTimeout(() => this.setState({ shareLinkOpen : false, menuOpen : false }), 1500)\n\n                }}\n                title='Get shareable link for this Box'\n              >\n                Share the URL\n              </div>\n              {\n                shareLinkOpen ?\n                  <p className='box-top-bar--menu-item--notif'>\n                    Link Copied!\n                  </p>\n                  :\n                  null\n              }\n              {/* <div\n                className='box-top-bar--menu-item'\n                onClick={ removeBox }\n                title='Delete this Box from the Notebook'\n              >\n                Remove\n              </div> */}\n\n              {/* <div\n                className='box-top-bar--menu-item'\n                title='Add another Box before this one'\n                onClick={ (e) => {\n                  e.stopPropagation()\n                  this.selectBoxType('before')\n                } }\n              >\n                New Box Before\n              </div> */}\n\n              {/* <div\n                className='box-top-bar--menu-item'\n                title='Add another Box after this one'\n                onClick={ (e) => {\n                  e.stopPropagation()\n                  this.selectBoxType('after')\n                } }\n              >\n                New Box After\n              </div> */}\n\n              <div\n                className='box-top-bar--menu-item'\n                title='Reset this Box to Initial State'\n                onClick={ (e) => {\n                  e.stopPropagation()\n                  // console.log('CLICKED ON RESET BOX')\n\n                  switch (type) {\n                    case BoxType.UNTYPED_LAMBDA: {\n                      // console.log('RESET UNTYPED LAMBDA')\n                      updateBoxState(resetUntypedLambdaBox(state as UntypedLambdaState))\n                      break\n                    }\n                    case BoxType.MARKDOWN: {\n                      // console.log('RESET MARODOWN')\n                      updateBoxState(resetMarkdownBox(state as NoteState))\n                      break\n                    }\n                  }\n                  this.setState({ menuOpen : false })\n                } }\n              >\n                Reset this Box\n              </div>\n            \n            </div>\n          :\n          null\n\n        }\n        \n      </div>\n      )\n    }\n\n\n  selectBoxType (place : BoxPlace) : void {\n    this.setState({ modalOpen : true, where : place })\n  }\n\n}","import React, { MouseEvent, PureComponent } from 'react'\nimport { mapBoxTypeToStr } from '../AppTypes'\nimport Box from './Box'\nimport BoxTitleBar from './BoxTitleBar'\nimport { BoxState, GlobalSettings, BoxesWhitelist } from '../Types'\n\nimport \"../styles/BoxContainer.css\"\n\n\ninterface Props {\n  isActiveBox : boolean\n  isFocusedBox : boolean\n  box : BoxState\n\n  makeActive : () => void\n  onBlur : () => void\n  updateBoxState : (state : BoxState) => void\n  removeBox : () => void\n  addBoxBefore : (state : BoxState) => void\n  addBoxAfter : (state : BoxState) => void\n  settings : GlobalSettings\n  whiteList : BoxesWhitelist\n}\n\nexport function BoxContainer (props : Props) : JSX.Element {\n  const {\n    isActiveBox,\n    isFocusedBox,\n    box,\n    makeActive,\n    onBlur,\n    updateBoxState,\n    addBoxBefore,\n    addBoxAfter,\n    removeBox\n  } : Props = props\n\n  const { settingsOpen } : BoxState = box\n\n  const boxTypeClassName : string = mapBoxTypeToStr(box.type)\n\n  return (\n    <div\n      className={ `boxContainer ${ isActiveBox ? 'active' : 'inactive' } ${boxTypeClassName}` }\n      onClick={ makeActive }\n      onBlur={ onBlur }\n    >\n      <BoxTitleBar\n        state={ box }\n        isActive={ isActiveBox }\n        isFocused={ isFocusedBox }\n        removeBox={ (e : MouseEvent) => {\n          e.stopPropagation()\n          removeBox()\n        } }\n        updateBoxState={ updateBoxState }\n        addBoxBefore={ addBoxBefore }\n        addBoxAfter={ addBoxAfter }\n        settings={ props.settings }\n        whiteList={ props.whiteList }\n      />\n      \n      <Box\n        state={ box }\n        isActive={ isActiveBox }\n        isFocused={ isFocusedBox }\n        updateBoxState={ updateBoxState }\n        addBoxAfter={ addBoxAfter }\n      />\n    </div>\n  )\n}","// This component needs to be able to specify which Boxes are allowed inside\n// It will also have other settings - maybe something like lock - if it's locked, you can not modify it\n// Exam mode will feature the build of the Frontend which will not import any of the Evaluation Boxes\n\n\nimport React, { PureComponent } from 'react'\nimport CreateBox from '../components/CreateBox'\nimport { BoxType, NotebookState, GlobalSettings, BoxState } from '../Types'\n\nimport { onMarkDownBlur, NoteState, onMarkDownActive } from '../markdown-integration/AppTypes'\nimport { BoxContainer } from '../components/BoxContainer'\nimport { UntypedLambdaState } from '../untyped-lambda-integration/Types'\n\ninterface Props {\n  state : NotebookState\n  settings : GlobalSettings\n\n  updateNotebook (notebook : Partial<NotebookState>) : void\n}\n\nexport default class Notebook extends PureComponent<Props> {\n  constructor (props : Props) {\n    super(props)\n\n    this.insertBefore = this.insertBefore.bind(this)\n    this.insertAfter = this.insertAfter.bind(this)\n    this.removeBox = this.removeBox.bind(this)\n    this.updateBoxState = this.updateBoxState.bind(this)\n    this.makeActive = this.makeActive.bind(this)\n    this.onBlur = this.onBlur.bind(this)\n    this.createBoxFromURL = this.createBoxFromURL.bind(this)\n    this.setBoxState = this.setBoxState.bind(this)\n    this.updateURL = this.updateURL.bind(this)\n  }\n\n  // componentDidMount () : void {\n  //   this.createBoxFromURL()\n  // }\n\n  render () {\n    const { state, settings } = this.props\n    const { activeBoxIndex, focusedBoxIndex, boxList, allowedBoxes } = state\n\n    return (\n      <div className=\"mainSpace\">\n        {/* TODO: This will be refactore out to standalone component. */}\n        <ul className=\"boxList UL\">\n          { boxList.map(\n            (box : BoxState, i : number) =>\n            <li className=\"LI\" key={ box.__key }>\n\n              {/* <CreateBox\n                addNew={ (box : BoxState) => this.insertBefore(i, box) }\n                whiteList={ allowedBoxes }\n                settings={ settings }\n              /> */}\n\n              <BoxContainer\n                box={ box}\n                isActiveBox={ activeBoxIndex === i}\n                isFocusedBox={ focusedBoxIndex === i }\n                addBoxBefore={ (box : BoxState) => this.insertBefore(i, box) }\n                addBoxAfter={ (box : BoxState) => this.insertAfter(i, box) }\n                makeActive={ () => this.makeActive(i) }\n                removeBox={ () => this.removeBox(i) }\n                updateBoxState={ (box : BoxState) => this.updateBoxState(i, box) }\n                onBlur={ () => this.onBlur(i) }\n                whiteList={ allowedBoxes }\n                settings={ settings }\n              />\n            </li>\n          ) }\n\n          {\n            boxList.length === 0 ?\n              <CreateBox\n                addNew={ (box : BoxState) => this.insertBefore(state.boxList.length, box) }\n                whiteList={ allowedBoxes }\n                settings={ settings }\n              />\n            :\n            null\n          }\n        </ul>\n      </div>\n    )\n  }\n\n  /**\n   * URL params:\n   *  type : untyped-lambda | markdown | lisp | ... \n   *  specific : {\n   *    SLI : nul\n   *    strategy : normal | applicative | simplyfied\n   *  }\n   *  source : string\n   */\n  createBoxFromURL () {\n    const urlSearchParams : URLSearchParams = new URL(window.location.toString()).searchParams\n    const type : string | null = urlSearchParams.get('type')\n\n    if (type === null) {\n      return\n    }\n\n    // switch (type) {\n    //   case BoxType.UNTYPED_LAMBDA: {\n\n    //   }\n        \n    //   default:\n    //     break;\n    // }\n    \n    // console.log(window.location.toString())\n    // console.log(urlSearchParams.get('type'))\n    // console.log(urlSearchParams.get('source'))\n\n\n\n\n    // const hash : string = decodeURI(window.location.hash.substring(1))\n    // const isExercise : boolean = hash.indexOf('exercise:') !== -1\n\n    // const expression : string = isExercise ? hash.substring(9) : hash\n\n    // if (expression === '') {\n    //   // return\n    // }\n\n    // const box : BoxState = {\n    //   type : BoxType.EXPRESSION,\n    //   __key : Date.now().toString(),\n    //   expression : '',\n    //   ast : null,\n    //   history : [],\n    //   isRunning : false,\n    //   breakpoints : [],\n    //   timeoutID : undefined,\n    //   timeout : 10,\n    //   isExercise : isExercise,\n    //   strategy : this.getActiveStrategy(),\n    //   singleLetterNames : this.getActiveSingleLetterNames(),\n    //   standalones : this.getActiveStandalones(),\n    //   editor : {\n    //     placeholder : PromptPlaceholder.INIT,\n    //     content : expression,\n    //     caretPosition : expression.length,\n    //     syntaxError : null,\n    //   }\n    // }\n\n    // this.setState({\n    //   ...this.state,\n    //   submittedBoxes : [ box ],\n    //   activeBoxIndex : 0,\n    // })\n  }\n\n  setBoxState (index : number, boxState : BoxState) : void {\n    // const { submittedBoxes } = this.state\n    \n    // const expression : string = boxState.type === BoxType.EXPRESSION ? boxState.editor.content || (boxState as EvaluationState).expression : '' // TODO: DIRTY DIRTY BIG TIME\n    // const expPrefix : string = boxState.type === BoxType.EXPRESSION && (boxState as EvaluationState).isExercise ? 'exercise:' : '' \n    \n    // history.pushState({}, \"page title?\", \"#\" + expPrefix + encodeURI(expression))\n\n    // // TODO: doresit update URL // ted uz to docela dobry je\n\n    // // TODO: consider immutability\n    // submittedBoxes[index] = boxState\n\n    // this.setState({\n    //   ...this.state,\n    //   submittedBoxes,\n    // })\n\n  }\n\n  insertBefore (index : number, box : BoxState) : void {\n    const { boxList } = this.props.state\n\n    const boxListCopy = [ ...boxList ]\n\n    boxListCopy.splice(index, 0, box)\n\n    this.props.updateNotebook({ boxList : boxListCopy, activeBoxIndex : index, focusedBoxIndex : index })\n  }\n\n  insertAfter (index : number, box : BoxState) : void {\n\n    const { boxList } = this.props.state\n\n    boxList.splice(index + 1, 0, box)\n    this.props.updateNotebook({ boxList : boxList, activeBoxIndex : index + 1, focusedBoxIndex : index + 1})\n  }\n\n  removeBox (index : number) : void {\n    const { boxList, activeBoxIndex } = this.props.state\n    \n    const nearestValidIndex = (i : number) => {\n      if (i < activeBoxIndex) return activeBoxIndex - 1\n      if (i > activeBoxIndex) return activeBoxIndex\n      if (boxList.length === 1) return NaN\n      if (i === 0) return i\n      return i - 1\n    }\n\n    const newIndex : number = nearestValidIndex(index)\n\n    boxList.splice(index, 1)\n    this.props.updateNotebook({ boxList : boxList, activeBoxIndex : newIndex })\n  }\n\n  updateBoxState (index : number, box : BoxState) : void {\n    // console.log('UPDATING BOX STATE')\n    const { boxList } = this.props.state\n    boxList[index] = { ...box }\n\n    this.updateURL(box)\n\n\n    this.props.updateNotebook({ boxList : [...boxList], activeBoxIndex : index })\n  }\n\n  makeActive (index : number) : void {\n    // console.log(\"CLICKED ON               MAKE ACTIVE \" + index)\n    const { activeBoxIndex, focusedBoxIndex, boxList } = this.props.state\n\n    const currentType : BoxType = boxList[activeBoxIndex].type\n\n    switch (currentType) {\n      case BoxType.UNTYPED_LAMBDA:\n        // boxList[activeBoxIndex] = onUntypedLambdaBlur(boxList[activeBoxIndex])\n        break\n      \n      case BoxType.MARKDOWN: {\n        boxList[activeBoxIndex] = onMarkDownBlur(boxList[activeBoxIndex] as NoteState)\n        break\n      }\n\n      default:\n        break\n    }\n\n    if (index !== activeBoxIndex || index !== focusedBoxIndex || boxList[index].minimized === true) {\n      const futureType : BoxType = boxList[index].type\n\n      const patch = {\n        minimized : false,\n      }\n\n      switch (futureType) {\n        case BoxType.MARKDOWN: {\n          boxList[index] = {\n            ...onMarkDownActive(boxList[index] as NoteState),\n            ...patch,\n          }\n        }\n          \n        default: {\n          boxList[index] = {\n            ...boxList[index],\n            ...patch\n          }\n        }\n          break;\n      }\n\n      this.updateURL(boxList[index])\n\n      this.props.updateNotebook({ activeBoxIndex : index, focusedBoxIndex : index, boxList })\n    }\n  }\n\n  onBlur (index : number) : void {\n    // TODO: I may not need onBlur handling in the future\n    // I am thinking - right now all it does is this:\n    // it un-focuses currently focused Box\n    // if this is not really needed - then maybe I should not have this feature\n    // console.log('..................................')\n    // console.log(\"                  BLUR \" + index)\n\n    const { boxList, activeBoxIndex } = this.props.state\n\n    if (activeBoxIndex !== index) {\n      return\n    }\n\n    const currentType : BoxType = boxList[index].type\n\n    switch (currentType) {\n      case BoxType.UNTYPED_LAMBDA:\n        // boxList[activeBoxIndex] = onUntypedLambdaBlur(boxList[activeBoxIndex])\n        break\n      \n      case BoxType.MARKDOWN: {\n        boxList[index] = onMarkDownBlur(boxList[index] as NoteState)\n        // return // TODO: just for now\n      }\n\n      default:\n        break\n    }\n\n    this.props.updateNotebook({ boxList, focusedBoxIndex : undefined })\n  }\n\n  updateURL (box : BoxState) : void {\n    return\n    switch (box.type) {\n      case BoxType.MARKDOWN : {\n        const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n        searchParams.set('type', BoxType.MARKDOWN)\n        searchParams.set('source', encodeURI((box as NoteState).editor.content))\n\n        window.history.pushState(null, '', '?' + searchParams.toString())\n        break;\n      }\n\n      case BoxType.UNTYPED_LAMBDA : {\n        const searchParams : URLSearchParams = new URL(window.document.location.toString()).searchParams\n\n        searchParams.set('type', BoxType.UNTYPED_LAMBDA)\n        searchParams.set('source', encodeURI((box as UntypedLambdaState).editor.content))\n\n        window.history.pushState(null, '', '?' + searchParams.toString())\n\n        break;\n      }\n    \n      default:\n        break;\n    }\n  }\n}","import React from 'react'\nimport 'github-markdown-css'\n\nimport guide from '../misc/UserGuide'\nconst ReactMarkdown = require('react-markdown')\n\nexport default function Help (props : {}) : JSX.Element {\n  return (\n  <div className='helpSpace'>\n    <ReactMarkdown className='markdown-body' source={ guide } />    \n  </div>)\n}","export default `# User guide\n\n## Typing expressions\n#### To write lambda expression you simply type in the prompt.\n\n## Typing λ symbol\n#### If you want to write \\`λ\\` symbol inside of the Interactive Box - you simply type \\`\\\\\\` and Lambdulus will take care of the rest.\n\n#### If you need to write \\`λ\\` symbol inside of the Markdown Box - you can use \\`&lambda;\\` sequence.\n\n## Multiple expressions\n#### You can also have many submitted expressions. To submit another expression you need to open new empty \\`expression box\\` by clicking on the \\`λ\\` inside the \\`+λ +Macro +MD\\` panel at the end of the notebook.\n\n## Single Letter Names (SLI)\n#### You can write lambda functions and omit whitespaces such as \\`(λabc.cba) 2 1 +\\`. To do that you have to check switch \\`Single Letter Names\\` at the top of the page.\n\n## Evaluation Strategies\n#### We have option to select from 3 evaluation strategies. The \\`Simplified\\` strategy is specific evaluation order which evaluates built-in macros atomicaly. The \\`Normal\\` and the \\`Applicative\\` strategies are sort of self describing.\n\n## Macros\n#### If you want to define your own macro - you can. You must first create empty \\`macro box\\` by clicking on the \\`+Macro\\` inside the \\`+λ +Macro +MD\\` panel at the end of the notebook. Then you write macro name followed by symbol \\`:=\\` and then valid lambda expression.\n\n## Macro Definition\n#### Inside the macro definition you can reference any valid macro which is already defined or will be defined in the future. Yes you can reference macro you are just defining inside it's own definition - whether you should or not is up to you.\n\n## List All Macros\n#### If you want to list all defined macros - built-ins and also your macros - you simply click on the \\`Macro\\` icon at the top or on the left of the page.\n\n## Remove User Macro\n#### To remove user macros - \\`because you can not remove built-ins\\` - first show all macros and then hover your mouse over the macro you want to remove and click the \\`trash bin\\` icon.\n\n## Redefine User Macro\n#### To redefine user macro - \\`because you can not redefine built-ins\\` - just create new empty \\`macro box\\` and define the already existing macro again - this time with different macro definition.\n\n## Report a Bug or Request New Features\n#### If you want to report a bug or you need some feature - click on the \\`Issues\\` button on the left or at the top of the page. Then fill in the issue on the GitHub page of the project. Definitely don't forget to check if the corresponding issue already exist.\n`","import React from 'react'\n\nimport UntypedLambdaCalculusSet from '../untyped-lambda-integration/Settings'\nimport {\n  CODE_NAME as UNTYPED_CODE_NAME,\n  GLOBAL_SETTINGS_ENABLER as UNTYPED_GLOBAL_SETTINGS_ENABLER\n} from '../untyped-lambda-integration/AppTypes'\nimport { GlobalSettings } from '../Types'\nimport { UntypedLambdaSettings } from '../untyped-lambda-integration/Types'\n\n\ninterface Props {\n  settings : GlobalSettings\n  updateSettings : (settings : GlobalSettings) => void\n}\n\nexport default function SettingsScreen (props : Props) : JSX.Element {\n  const { settings, updateSettings } = props\n\n  const untypedSettings : UntypedLambdaSettings = settings[UNTYPED_CODE_NAME] as UntypedLambdaSettings\n\n  return (\n    <div className='settingsSpace'>\n      <h2>\n        Settings for Untyped Lambda Calculus:\n      </h2>\n      <UntypedLambdaCalculusSet\n        settings={ untypedSettings }\n        settingsEnabled={ UNTYPED_GLOBAL_SETTINGS_ENABLER }\n        change={\n          (unTypLSet : UntypedLambdaSettings) =>\n            updateSettings({ ...settings, [UNTYPED_CODE_NAME] : unTypLSet })\n        }\n      />\n    </div>\n  )\n}","import React, { Component } from 'react'\n\nimport './App.css'\n\nimport { updateSettingsInStorage, loadAppStateFromStorage, updateAppStateToStorage, updateNotebookStateToStorage, CLEAR_WORKSPACE_CONFIRMATION, loadSettingsFromStorage, ANY_BOX, initIntegrationStates, InitNotebookState, DEFAULT_WHITELIST, HoloAppState, HoloNotebookState } from './AppTypes'\n\nimport TopBar from './components/TopBar'\nimport MenuBar from './components/MenuBar'\nimport Notebook from './screens/Notebook'\nimport Help from './screens/Help'\nimport SettingsScreen from './screens/Settings'\nimport { Screen, AppState, NotebookState, GlobalSettings, BoxType, BoxState } from './Types'\nimport { UNTYPED_LAMBDA_INTEGRATION_STATE, createNewUntypedLambdaBoxFromSource, defaultSettings } from './untyped-lambda-integration/AppTypes'\nimport NotebookList from './screens/NotebookList'\nimport { UntypedLambdaState, UntypedLambdaSettings, EvaluationStrategy, UntypedLambdaType } from './untyped-lambda-integration/Types'\n\n\n\n/**\n * This is the main Application\n * in the future - when building Exam Mode - I will need to replace some part of the application components\n * if it's only some component at the top, it can be done easily\n * if it's gonna replace some deeper stuff I will need to implement some Namespace FROM which app and integrations\n * will inport parts and this Namespace will take care of that\n */\n\n\ninterface Props {}\nexport default class App extends Component<Props, AppState> {\n  constructor (props : Props) {\n    super(props)\n\n    this.state = { ...HoloAppState }\n\n    // initIntegrationStates(this.state)\n\n    this.setScreen = this.setScreen.bind(this)\n    this.updateNotebook = this.updateNotebook.bind(this)\n    this.changeNotebook = this.changeNotebook.bind(this)\n    // this.addNotebook = this.addNotebook.bind(this)\n    // this.removeNotebook = this.removeNotebook.bind(this)\n    // this.editNotebookName = this.editNotebookName.bind(this)\n    // this.changeNotebookName = this.changeNotebookName.bind(this)\n    // this.stopEditingNotebook = this.stopEditingNotebook.bind(this)\n    this.updateSettings = this.updateSettings.bind(this)\n    // this.importNotebook = this.importNotebook.bind(this)\n    // this.importWorkspace = this.importWorkspace.bind(this)\n    this.clearWorkspace = this.clearWorkspace.bind(this)\n    this.selectNotebook = this.selectNotebook.bind(this)\n    this.updateNthNotebook = this.updateNthNotebook.bind(this)\n\n    this.createNotebookFromURL = this.createNotebookFromURL.bind(this)\n  }\n\n  componentDidMount () : void {\n    this.createNotebookFromURL()\n  }\n\n  // TODO: all of this needs to be moved to more apropriate component\n  // maybe something like Notebook or similar -- this just isn't right\n  createNotebookFromURL () {\n    const urlSearchParams : URLSearchParams = new URL(window.location.toString()).searchParams\n    const type : string | null = urlSearchParams.get('type')\n\n    if (type === null) {\n      return\n    }\n\n    switch (type) {\n      case BoxType.UNTYPED_LAMBDA: {\n        const source : string | null = urlSearchParams.get('source')\n        const subtype : string | null = urlSearchParams.get('subtype')\n        const strategy : string | null = urlSearchParams.get('strategy')\n        const SDE : string | null = urlSearchParams.get('SDE')\n        const SLI : string | null = urlSearchParams.get('SLI')\n        \n        if (source === null || subtype === null || strategy === null || SDE === null || SLI === null) {\n          return\n        }\n\n        const strat : EvaluationStrategy = EvaluationStrategy.NORMAL === strategy ? EvaluationStrategy.NORMAL : EvaluationStrategy.APPLICATIVE\n\n        const sli : boolean = SLI === 'true' ? true : false\n\n        const settings : UntypedLambdaSettings = { ...defaultSettings, strategy : strat, SDE : SDE === 'true' ? true : false, SLI : sli }\n\n        const sub : UntypedLambdaType = subtype === UntypedLambdaType.EMPTY ?\n            UntypedLambdaType.EMPTY\n          :\n            subtype === UntypedLambdaType.ORDINARY ?\n              UntypedLambdaType.ORDINARY\n            :\n              subtype === UntypedLambdaType.EXERCISE ?\n                UntypedLambdaType.EXERCISE\n              :\n                UntypedLambdaType.EMPTY\n\n        try {\n          const box : UntypedLambdaState = createNewUntypedLambdaBoxFromSource(decodeURI(source), settings, sub)\n          const notebook : NotebookState = createNewNotebookWithBox('Notebook from Link' , box)\n\n          this.setState({\n            currentScreen : Screen.MAIN,\n            notebookList : [ notebook ],\n            currentNotebook : 0\n          })\n\n          window.history.pushState(null, '', '/') // TODO: decide if remove or leave\n\n          // updateAppStateToStorage({\n          //   ...this.state,\n          //   currentScreen : Screen.MAIN,\n          //   notebookList : [ ...this.state.notebookList, notebook ],\n          //   currentNotebook : this.state.notebookList.length - 1\n          // })\n        }\n        catch (ex) {\n          window.history.replaceState(null, '', '/') // TODO: decide if remove or leave\n        }\n      }\n        \n      default:\n        break;\n    }\n  }\n\n  render () {\n    const { notebookList, currentNotebook, currentScreen } = this.state\n    const state = notebookList[currentNotebook]\n    const { settings } = state\n\n    return (\n      <div id='app'>\n        <TopBar\n          state={ this.state }\n          onScreenChange={ this.setScreen }\n          onImport={ () => void 0 }\n          onClearWorkspace={ () => window.location.reload() }\n        />\n\n\n        <MenuBar\n          state={ this.state }\n          onScreenChange={ this.setScreen }\n        />\n\n        {\n          (() => {\n            if (currentScreen === Screen.MAIN)\n              return <Notebook state={ state } updateNotebook={ this.updateNotebook } settings={ settings } />\n            // if (currentScreen === Screen.NOTEBOOKS)\n            //   return  <NotebookList\n            //             state={ this.state }\n            //             onSelectNotebook={ this.selectNotebook }\n            //             onRemoveNotebook={ this.removeNotebook }\n            //             onUpdateNotebook={ this.updateNthNotebook }\n            //             onAddNotebook={ this.addNotebook }\n            //           />\n            if (currentScreen === Screen.HELP)\n              return <Help/>\n            if (currentScreen === Screen.SETTINGS) {\n              // console.log('settings')\n              return <SettingsScreen settings={ settings } updateSettings={ this.updateSettings } />\n            }\n          })()\n        }\n        \n      </div>\n    )\n  }\n\n  selectNotebook (index : number) : void {\n    this.setState({\n      currentScreen : Screen.MAIN,\n      currentNotebook : index,\n    })\n\n    // updateAppStateToStorage({\n    //   ...this.state,\n    //   currentScreen : Screen.MAIN,\n    //   currentNotebook : index,\n    // })\n\n    // window.history.pushState(null, '', '/')\n  }\n\n  setScreen (screen : Screen) : void {\n    // console.log('set state screen ', screen)\n    this.setState({ currentScreen : screen })\n  }\n\n  updateNotebook (notebook : Partial<NotebookState>) : void {\n\n    // console.log('??????????????????????????????????????')\n    // console.log(notebook.boxList.length)\n    // console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')\n\n\n\n    const { notebookList, currentNotebook } = this.state\n\n    notebookList[currentNotebook] = {\n      ...notebookList[currentNotebook],\n      ...notebook,\n    }\n\n    this.setState({ notebookList })\n\n    // updateNotebookStateToStorage(notebookList[currentNotebook], currentNotebook)\n    // updateAppStateToStorage({ ...this.state })\n    // NOTE: Carefuly around here - I kinda rely on the mutation of this.state.notebookList\n  }\n\n  updateNthNotebook (notebook : NotebookState, index : number) : void {\n    const { notebookList } = this.state\n    notebookList[index] = notebook\n\n    this.setState({ notebookList })\n\n    // updateNotebookStateToStorage(notebook, index)\n  }\n\n  changeNotebook (index : number) : void {\n    this.setState({ currentNotebook : index })\n    // updateAppStateToStorage({ ...this.state, currentNotebook : index })\n  }\n\n  // addNotebook (name : string = '') : void {\n  //   this.setState({\n  //     notebookList : [ ...this.state.notebookList, createNewNotebook(name) ],\n  //     currentNotebook : this.state.currentNotebook + 1\n  //   })\n\n  //   // updateAppStateToStorage({\n  //   //   ...this.state,\n  //   //   currentScreen : Screen.MAIN,\n  //   //   notebookList : [ ...this.state.notebookList, createNewNotebook(name) ],\n  //   //   currentNotebook : this.state.currentNotebook + 1\n  //   // })\n  // }\n\n  // importNotebook (notebook : NotebookState) : void {\n  //   this.setState({\n  //     notebookList : [ ...this.state.notebookList, notebook ],\n  //     currentNotebook : this.state.currentNotebook + 1\n  //   })\n\n  //   // updateAppStateToStorage({\n  //   //   ...this.state,\n  //   //   notebookList : [ ...this.state.notebookList, notebook ],\n  //   //   currentNotebook : this.state.currentNotebook + 1\n  //   // })\n  // }\n\n  // removeNotebook (index : number) : void {\n  //   // if (index === 0) return\n\n  //   const { notebookList, currentNotebook } = this.state\n    \n  //   const nearestValidIndex = (i : number) => {\n  //     if (i < currentNotebook) return currentNotebook - 1\n  //     if (i > currentNotebook) return currentNotebook\n  //     if (notebookList.length === 1) return NaN\n  //     if (i === 0) return i\n  //     return i - 1\n  //   }\n    \n  //   const newIndex : number = nearestValidIndex(index)\n    \n  //   if (Number.isNaN(newIndex)) return\n\n  //   notebookList.splice(index, 1)\n\n  //   this.setState({ notebookList, currentNotebook : newIndex })\n  //   // updateAppStateToStorage({\n  //   //   ...this.state,\n  //   //   notebookList,\n  //   //   currentNotebook : newIndex,\n  //   // })\n  // }\n\n  // editNotebookName (index : number) : void {\n  //   const { notebookList } = this.state\n\n  //   const notebook : NotebookState = notebookList[index]\n\n  //   notebookList[index] = { ...notebook, editingName : true, persistent : true }\n\n  //   this.setState({ notebookList })\n  //   updateNotebookStateToStorage(notebook, index)\n  //   // updateAppStateToStorage({ ...this.state })\n  // }\n\n  // changeNotebookName (index : number, name : string) : void {\n  //   const { notebookList } = this.state\n\n  //   const notebook : NotebookState = notebookList[index]\n\n  //   notebookList[index] = { ...notebook, name }\n\n  //   this.setState({ notebookList })\n  //   updateNotebookStateToStorage(notebook, index)\n\n  //   // updateAppStateToStorage({ ...this.state })\n  // }\n\n  // stopEditingNotebook (index : number) : void {\n  //   const { notebookList } = this.state\n\n  //   const notebook : NotebookState = notebookList[index]\n\n  //   notebookList[index] = { ...notebook, editingName : false }\n\n  //   this.setState({ notebookList })\n  //   // updateNotebookStateToStorage(notebook, index)\n  //   // updateAppStateToStorage({ ...this.state })\n  // }\n\n  updateSettings (newSettings : GlobalSettings) : void {\n    const { currentNotebook, notebookList } = this.state\n    notebookList[currentNotebook].settings = newSettings\n\n    this.setState({ notebookList : [...notebookList] })\n    // updateSettingsInStorage(newSettings)\n  }\n\n  // importWorkspace (state : AppState) : void {\n  //   this.setState(state)\n  //   updateAppStateToStorage(state)\n  // }\n\n  clearWorkspace () : void {\n    if (window.confirm(CLEAR_WORKSPACE_CONFIRMATION)) {\n\n      // localStorage.removeItem('AppState')\n      const { currentNotebook, notebookList } = this.state\n\n      console.log('//////////////////////////////////////////////////')\n      console.log([ ...notebookList ])\n\n      this.setState({ notebookList : [{ ...HoloNotebookState }] })\n      // updateNotebookStateToStorage(InitNotebookState, currentNotebook)\n\n      // updateAppStateToStorage(this.state)\n\n      // this.setState(loadAppStateFromStorage())\n    }\n  }\n}\n\n// function createNewNotebook (name : string = 'Anonymous Notebook') : NotebookState {\n//   return {\n//     boxList : [],\n//     activeBoxIndex : NaN,\n//     focusedBoxIndex : undefined,\n//     allowedBoxes : DEFAULT_WHITELIST,\n//     settings : loadSettingsFromStorage(),\n//     integrationStates : {\n//       'UNTYPED_LAMBDA' : UNTYPED_LAMBDA_INTEGRATION_STATE,\n//     },\n\n//     locked : false,\n//     menuOpen : false,\n    \n//     __key : Date.now().toString(),\n//     name,\n//     editingName : false,\n//     persistent : true, // TODO: you can change this if explicit save/rename is required for persistency\n//   }\n// }\n\nfunction createNewNotebookWithBox (name : string = 'Notebook from Link', box : BoxState) : NotebookState {\n  return {\n    boxList : [ box ],\n    activeBoxIndex : 0,\n    focusedBoxIndex : 0,\n    allowedBoxes : DEFAULT_WHITELIST,\n    settings : loadSettingsFromStorage(),\n    integrationStates : {\n      'UNTYPED_LAMBDA' : UNTYPED_LAMBDA_INTEGRATION_STATE,\n    },\n\n    locked : false,\n    menuOpen : false,\n    \n    __key : Date.now().toString(),\n    name,\n    editingName : false,\n    persistent : true, // TODO: you can change this if explicit save/rename is required for persistency\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}